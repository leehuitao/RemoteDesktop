// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: histogram.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_histogram_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_histogram_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_histogram_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_histogram_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace catapult {
namespace tracing {
namespace tracing {
namespace proto {
class Bin;
class BinDefaultTypeInternal;
extern BinDefaultTypeInternal _Bin_default_instance_;
class BinBoundaries;
class BinBoundariesDefaultTypeInternal;
extern BinBoundariesDefaultTypeInternal _BinBoundaries_default_instance_;
class BinBoundaryDetailedSpec;
class BinBoundaryDetailedSpecDefaultTypeInternal;
extern BinBoundaryDetailedSpecDefaultTypeInternal _BinBoundaryDetailedSpec_default_instance_;
class BinBoundarySpec;
class BinBoundarySpecDefaultTypeInternal;
extern BinBoundarySpecDefaultTypeInternal _BinBoundarySpec_default_instance_;
class Breakdown;
class BreakdownDefaultTypeInternal;
extern BreakdownDefaultTypeInternal _Breakdown_default_instance_;
class DateRange;
class DateRangeDefaultTypeInternal;
extern DateRangeDefaultTypeInternal _DateRange_default_instance_;
class Diagnostic;
class DiagnosticDefaultTypeInternal;
extern DiagnosticDefaultTypeInternal _Diagnostic_default_instance_;
class DiagnosticMap;
class DiagnosticMapDefaultTypeInternal;
extern DiagnosticMapDefaultTypeInternal _DiagnosticMap_default_instance_;
class DiagnosticMap_DiagnosticMapEntry_DoNotUse;
class DiagnosticMap_DiagnosticMapEntry_DoNotUseDefaultTypeInternal;
extern DiagnosticMap_DiagnosticMapEntry_DoNotUseDefaultTypeInternal _DiagnosticMap_DiagnosticMapEntry_DoNotUse_default_instance_;
class GenericSet;
class GenericSetDefaultTypeInternal;
extern GenericSetDefaultTypeInternal _GenericSet_default_instance_;
class Histogram;
class HistogramDefaultTypeInternal;
extern HistogramDefaultTypeInternal _Histogram_default_instance_;
class HistogramSet;
class HistogramSetDefaultTypeInternal;
extern HistogramSetDefaultTypeInternal _HistogramSet_default_instance_;
class HistogramSet_SharedDiagnosticsEntry_DoNotUse;
class HistogramSet_SharedDiagnosticsEntry_DoNotUseDefaultTypeInternal;
extern HistogramSet_SharedDiagnosticsEntry_DoNotUseDefaultTypeInternal _HistogramSet_SharedDiagnosticsEntry_DoNotUse_default_instance_;
class Histogram_AllBinsEntry_DoNotUse;
class Histogram_AllBinsEntry_DoNotUseDefaultTypeInternal;
extern Histogram_AllBinsEntry_DoNotUseDefaultTypeInternal _Histogram_AllBinsEntry_DoNotUse_default_instance_;
class RelatedEventSet;
class RelatedEventSetDefaultTypeInternal;
extern RelatedEventSetDefaultTypeInternal _RelatedEventSet_default_instance_;
class RelatedNameMap;
class RelatedNameMapDefaultTypeInternal;
extern RelatedNameMapDefaultTypeInternal _RelatedNameMap_default_instance_;
class RunningStatistics;
class RunningStatisticsDefaultTypeInternal;
extern RunningStatisticsDefaultTypeInternal _RunningStatistics_default_instance_;
class Scalar;
class ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class SummaryOptions;
class SummaryOptionsDefaultTypeInternal;
extern SummaryOptionsDefaultTypeInternal _SummaryOptions_default_instance_;
class UnitAndDirection;
class UnitAndDirectionDefaultTypeInternal;
extern UnitAndDirectionDefaultTypeInternal _UnitAndDirection_default_instance_;
}  // namespace proto
}  // namespace tracing
}  // namespace tracing
}  // namespace catapult
PROTOBUF_NAMESPACE_OPEN
template<> ::catapult::tracing::tracing::proto::Bin* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Bin>(Arena*);
template<> ::catapult::tracing::tracing::proto::BinBoundaries* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::BinBoundaries>(Arena*);
template<> ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec>(Arena*);
template<> ::catapult::tracing::tracing::proto::BinBoundarySpec* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::BinBoundarySpec>(Arena*);
template<> ::catapult::tracing::tracing::proto::Breakdown* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Breakdown>(Arena*);
template<> ::catapult::tracing::tracing::proto::DateRange* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::DateRange>(Arena*);
template<> ::catapult::tracing::tracing::proto::Diagnostic* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Diagnostic>(Arena*);
template<> ::catapult::tracing::tracing::proto::DiagnosticMap* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::DiagnosticMap>(Arena*);
template<> ::catapult::tracing::tracing::proto::DiagnosticMap_DiagnosticMapEntry_DoNotUse* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::DiagnosticMap_DiagnosticMapEntry_DoNotUse>(Arena*);
template<> ::catapult::tracing::tracing::proto::GenericSet* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::GenericSet>(Arena*);
template<> ::catapult::tracing::tracing::proto::Histogram* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Histogram>(Arena*);
template<> ::catapult::tracing::tracing::proto::HistogramSet* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::HistogramSet>(Arena*);
template<> ::catapult::tracing::tracing::proto::HistogramSet_SharedDiagnosticsEntry_DoNotUse* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::HistogramSet_SharedDiagnosticsEntry_DoNotUse>(Arena*);
template<> ::catapult::tracing::tracing::proto::Histogram_AllBinsEntry_DoNotUse* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Histogram_AllBinsEntry_DoNotUse>(Arena*);
template<> ::catapult::tracing::tracing::proto::RelatedEventSet* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::RelatedEventSet>(Arena*);
template<> ::catapult::tracing::tracing::proto::RelatedNameMap* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::RelatedNameMap>(Arena*);
template<> ::catapult::tracing::tracing::proto::RunningStatistics* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::RunningStatistics>(Arena*);
template<> ::catapult::tracing::tracing::proto::Scalar* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Scalar>(Arena*);
template<> ::catapult::tracing::tracing::proto::SummaryOptions* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::SummaryOptions>(Arena*);
template<> ::catapult::tracing::tracing::proto::UnitAndDirection* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::UnitAndDirection>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace catapult {
namespace tracing {
namespace tracing {
namespace proto {

enum BinBoundaryDetailedSpec_Type : int {
  BinBoundaryDetailedSpec_Type_LINEAR = 0,
  BinBoundaryDetailedSpec_Type_EXPONENTIAL = 1,
  BinBoundaryDetailedSpec_Type_BinBoundaryDetailedSpec_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BinBoundaryDetailedSpec_Type_BinBoundaryDetailedSpec_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BinBoundaryDetailedSpec_Type_IsValid(int value);
constexpr BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec_Type_Type_MIN = BinBoundaryDetailedSpec_Type_LINEAR;
constexpr BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec_Type_Type_MAX = BinBoundaryDetailedSpec_Type_EXPONENTIAL;
constexpr int BinBoundaryDetailedSpec_Type_Type_ARRAYSIZE = BinBoundaryDetailedSpec_Type_Type_MAX + 1;

const std::string& BinBoundaryDetailedSpec_Type_Name(BinBoundaryDetailedSpec_Type value);
template<typename T>
inline const std::string& BinBoundaryDetailedSpec_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinBoundaryDetailedSpec_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinBoundaryDetailedSpec_Type_Name.");
  return BinBoundaryDetailedSpec_Type_Name(static_cast<BinBoundaryDetailedSpec_Type>(enum_t_value));
}
bool BinBoundaryDetailedSpec_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BinBoundaryDetailedSpec_Type* value);
enum ImprovementDirection : int {
  NOT_SPECIFIED = 0,
  BIGGER_IS_BETTER = 1,
  SMALLER_IS_BETTER = 2,
  ImprovementDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImprovementDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImprovementDirection_IsValid(int value);
constexpr ImprovementDirection ImprovementDirection_MIN = NOT_SPECIFIED;
constexpr ImprovementDirection ImprovementDirection_MAX = SMALLER_IS_BETTER;
constexpr int ImprovementDirection_ARRAYSIZE = ImprovementDirection_MAX + 1;

const std::string& ImprovementDirection_Name(ImprovementDirection value);
template<typename T>
inline const std::string& ImprovementDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImprovementDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImprovementDirection_Name.");
  return ImprovementDirection_Name(static_cast<ImprovementDirection>(enum_t_value));
}
bool ImprovementDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImprovementDirection* value);
enum Unit : int {
  MS = 0,
  MS_BEST_FIT_FORMAT = 1,
  TS_MS = 2,
  N_PERCENT = 3,
  SIZE_IN_BYTES = 4,
  BYTES_PER_SECOND = 5,
  J = 6,
  W = 7,
  A = 8,
  V = 9,
  HERTZ = 10,
  UNITLESS = 11,
  COUNT = 12,
  SIGMA = 13,
  AH = 14,
  Unit_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Unit_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Unit_IsValid(int value);
constexpr Unit Unit_MIN = MS;
constexpr Unit Unit_MAX = AH;
constexpr int Unit_ARRAYSIZE = Unit_MAX + 1;

const std::string& Unit_Name(Unit value);
template<typename T>
inline const std::string& Unit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Unit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Unit_Name.");
  return Unit_Name(static_cast<Unit>(enum_t_value));
}
bool Unit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Unit* value);
// ===================================================================

class UnitAndDirection PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.UnitAndDirection) */ {
 public:
  inline UnitAndDirection() : UnitAndDirection(nullptr) {}
  virtual ~UnitAndDirection();

  UnitAndDirection(const UnitAndDirection& from);
  UnitAndDirection(UnitAndDirection&& from) noexcept
    : UnitAndDirection() {
    *this = ::std::move(from);
  }

  inline UnitAndDirection& operator=(const UnitAndDirection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitAndDirection& operator=(UnitAndDirection&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UnitAndDirection& default_instance();

  static inline const UnitAndDirection* internal_default_instance() {
    return reinterpret_cast<const UnitAndDirection*>(
               &_UnitAndDirection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UnitAndDirection& a, UnitAndDirection& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UnitAndDirection* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitAndDirection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitAndDirection* New() const final {
    return CreateMaybeMessage<UnitAndDirection>(nullptr);
  }

  UnitAndDirection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitAndDirection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const UnitAndDirection& from);
  void MergeFrom(const UnitAndDirection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnitAndDirection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.UnitAndDirection";
  }
  protected:
  explicit UnitAndDirection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
    kImprovementDirectionFieldNumber = 2,
  };
  // .catapult.tracing.tracing.proto.Unit unit = 1;
  void clear_unit();
  ::catapult::tracing::tracing::proto::Unit unit() const;
  void set_unit(::catapult::tracing::tracing::proto::Unit value);
  private:
  ::catapult::tracing::tracing::proto::Unit _internal_unit() const;
  void _internal_set_unit(::catapult::tracing::tracing::proto::Unit value);
  public:

  // .catapult.tracing.tracing.proto.ImprovementDirection improvement_direction = 2;
  void clear_improvement_direction();
  ::catapult::tracing::tracing::proto::ImprovementDirection improvement_direction() const;
  void set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value);
  private:
  ::catapult::tracing::tracing::proto::ImprovementDirection _internal_improvement_direction() const;
  void _internal_set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value);
  public:

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.UnitAndDirection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int unit_;
  int improvement_direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class BinBoundaryDetailedSpec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec) */ {
 public:
  inline BinBoundaryDetailedSpec() : BinBoundaryDetailedSpec(nullptr) {}
  virtual ~BinBoundaryDetailedSpec();

  BinBoundaryDetailedSpec(const BinBoundaryDetailedSpec& from);
  BinBoundaryDetailedSpec(BinBoundaryDetailedSpec&& from) noexcept
    : BinBoundaryDetailedSpec() {
    *this = ::std::move(from);
  }

  inline BinBoundaryDetailedSpec& operator=(const BinBoundaryDetailedSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinBoundaryDetailedSpec& operator=(BinBoundaryDetailedSpec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BinBoundaryDetailedSpec& default_instance();

  static inline const BinBoundaryDetailedSpec* internal_default_instance() {
    return reinterpret_cast<const BinBoundaryDetailedSpec*>(
               &_BinBoundaryDetailedSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BinBoundaryDetailedSpec& a, BinBoundaryDetailedSpec& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BinBoundaryDetailedSpec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinBoundaryDetailedSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinBoundaryDetailedSpec* New() const final {
    return CreateMaybeMessage<BinBoundaryDetailedSpec>(nullptr);
  }

  BinBoundaryDetailedSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinBoundaryDetailedSpec>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BinBoundaryDetailedSpec& from);
  void MergeFrom(const BinBoundaryDetailedSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BinBoundaryDetailedSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.BinBoundaryDetailedSpec";
  }
  protected:
  explicit BinBoundaryDetailedSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BinBoundaryDetailedSpec_Type Type;
  static constexpr Type LINEAR =
    BinBoundaryDetailedSpec_Type_LINEAR;
  static constexpr Type EXPONENTIAL =
    BinBoundaryDetailedSpec_Type_EXPONENTIAL;
  static inline bool Type_IsValid(int value) {
    return BinBoundaryDetailedSpec_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    BinBoundaryDetailedSpec_Type_Type_MIN;
  static constexpr Type Type_MAX =
    BinBoundaryDetailedSpec_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    BinBoundaryDetailedSpec_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return BinBoundaryDetailedSpec_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return BinBoundaryDetailedSpec_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMaximumBinBoundaryFieldNumber = 2,
    kBoundaryTypeFieldNumber = 1,
    kNumBinBoundariesFieldNumber = 3,
  };
  // double maximum_bin_boundary = 2;
  void clear_maximum_bin_boundary();
  double maximum_bin_boundary() const;
  void set_maximum_bin_boundary(double value);
  private:
  double _internal_maximum_bin_boundary() const;
  void _internal_set_maximum_bin_boundary(double value);
  public:

  // .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.Type boundary_type = 1;
  void clear_boundary_type();
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type boundary_type() const;
  void set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value);
  private:
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type _internal_boundary_type() const;
  void _internal_set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value);
  public:

  // int32 num_bin_boundaries = 3;
  void clear_num_bin_boundaries();
  ::PROTOBUF_NAMESPACE_ID::int32 num_bin_boundaries() const;
  void set_num_bin_boundaries(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_bin_boundaries() const;
  void _internal_set_num_bin_boundaries(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double maximum_bin_boundary_;
  int boundary_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_bin_boundaries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class BinBoundarySpec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.BinBoundarySpec) */ {
 public:
  inline BinBoundarySpec() : BinBoundarySpec(nullptr) {}
  virtual ~BinBoundarySpec();

  BinBoundarySpec(const BinBoundarySpec& from);
  BinBoundarySpec(BinBoundarySpec&& from) noexcept
    : BinBoundarySpec() {
    *this = ::std::move(from);
  }

  inline BinBoundarySpec& operator=(const BinBoundarySpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinBoundarySpec& operator=(BinBoundarySpec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BinBoundarySpec& default_instance();

  enum BoundaryOneofCase {
    kBinBoundary = 1,
    kBinSpec = 2,
    BOUNDARY_ONEOF_NOT_SET = 0,
  };

  static inline const BinBoundarySpec* internal_default_instance() {
    return reinterpret_cast<const BinBoundarySpec*>(
               &_BinBoundarySpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BinBoundarySpec& a, BinBoundarySpec& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BinBoundarySpec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinBoundarySpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinBoundarySpec* New() const final {
    return CreateMaybeMessage<BinBoundarySpec>(nullptr);
  }

  BinBoundarySpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinBoundarySpec>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BinBoundarySpec& from);
  void MergeFrom(const BinBoundarySpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BinBoundarySpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.BinBoundarySpec";
  }
  protected:
  explicit BinBoundarySpec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinBoundaryFieldNumber = 1,
    kBinSpecFieldNumber = 2,
  };
  // double bin_boundary = 1;
  private:
  bool _internal_has_bin_boundary() const;
  public:
  void clear_bin_boundary();
  double bin_boundary() const;
  void set_bin_boundary(double value);
  private:
  double _internal_bin_boundary() const;
  void _internal_set_bin_boundary(double value);
  public:

  // .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec bin_spec = 2;
  bool has_bin_spec() const;
  private:
  bool _internal_has_bin_spec() const;
  public:
  void clear_bin_spec();
  const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& bin_spec() const;
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* release_bin_spec();
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* mutable_bin_spec();
  void set_allocated_bin_spec(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* bin_spec);
  private:
  const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& _internal_bin_spec() const;
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* _internal_mutable_bin_spec();
  public:
  void unsafe_arena_set_allocated_bin_spec(
      ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* bin_spec);
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* unsafe_arena_release_bin_spec();

  void clear_boundary_oneof();
  BoundaryOneofCase boundary_oneof_case() const;
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.BinBoundarySpec)
 private:
  class _Internal;
  void set_has_bin_boundary();
  void set_has_bin_spec();

  inline bool has_boundary_oneof() const;
  inline void clear_has_boundary_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union BoundaryOneofUnion {
    BoundaryOneofUnion() {}
    double bin_boundary_;
    ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* bin_spec_;
  } boundary_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class BinBoundaries PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.BinBoundaries) */ {
 public:
  inline BinBoundaries() : BinBoundaries(nullptr) {}
  virtual ~BinBoundaries();

  BinBoundaries(const BinBoundaries& from);
  BinBoundaries(BinBoundaries&& from) noexcept
    : BinBoundaries() {
    *this = ::std::move(from);
  }

  inline BinBoundaries& operator=(const BinBoundaries& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinBoundaries& operator=(BinBoundaries&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BinBoundaries& default_instance();

  static inline const BinBoundaries* internal_default_instance() {
    return reinterpret_cast<const BinBoundaries*>(
               &_BinBoundaries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BinBoundaries& a, BinBoundaries& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BinBoundaries* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinBoundaries* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinBoundaries* New() const final {
    return CreateMaybeMessage<BinBoundaries>(nullptr);
  }

  BinBoundaries* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinBoundaries>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BinBoundaries& from);
  void MergeFrom(const BinBoundaries& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BinBoundaries* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.BinBoundaries";
  }
  protected:
  explicit BinBoundaries(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinSpecsFieldNumber = 2,
    kFirstBinBoundaryFieldNumber = 1,
  };
  // repeated .catapult.tracing.tracing.proto.BinBoundarySpec bin_specs = 2;
  int bin_specs_size() const;
  private:
  int _internal_bin_specs_size() const;
  public:
  void clear_bin_specs();
  ::catapult::tracing::tracing::proto::BinBoundarySpec* mutable_bin_specs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec >*
      mutable_bin_specs();
  private:
  const ::catapult::tracing::tracing::proto::BinBoundarySpec& _internal_bin_specs(int index) const;
  ::catapult::tracing::tracing::proto::BinBoundarySpec* _internal_add_bin_specs();
  public:
  const ::catapult::tracing::tracing::proto::BinBoundarySpec& bin_specs(int index) const;
  ::catapult::tracing::tracing::proto::BinBoundarySpec* add_bin_specs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec >&
      bin_specs() const;

  // double first_bin_boundary = 1;
  void clear_first_bin_boundary();
  double first_bin_boundary() const;
  void set_first_bin_boundary(double value);
  private:
  double _internal_first_bin_boundary() const;
  void _internal_set_first_bin_boundary(double value);
  public:

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.BinBoundaries)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec > bin_specs_;
  double first_bin_boundary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Breakdown PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Breakdown) */ {
 public:
  inline Breakdown() : Breakdown(nullptr) {}
  virtual ~Breakdown();

  Breakdown(const Breakdown& from);
  Breakdown(Breakdown&& from) noexcept
    : Breakdown() {
    *this = ::std::move(from);
  }

  inline Breakdown& operator=(const Breakdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline Breakdown& operator=(Breakdown&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Breakdown& default_instance();

  static inline const Breakdown* internal_default_instance() {
    return reinterpret_cast<const Breakdown*>(
               &_Breakdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Breakdown& a, Breakdown& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Breakdown* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Breakdown* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Breakdown* New() const final {
    return CreateMaybeMessage<Breakdown>(nullptr);
  }

  Breakdown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Breakdown>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Breakdown& from);
  void MergeFrom(const Breakdown& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Breakdown* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Breakdown";
  }
  protected:
  explicit Breakdown(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Breakdown)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class DateRange PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.DateRange) */ {
 public:
  inline DateRange() : DateRange(nullptr) {}
  virtual ~DateRange();

  DateRange(const DateRange& from);
  DateRange(DateRange&& from) noexcept
    : DateRange() {
    *this = ::std::move(from);
  }

  inline DateRange& operator=(const DateRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateRange& operator=(DateRange&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DateRange& default_instance();

  static inline const DateRange* internal_default_instance() {
    return reinterpret_cast<const DateRange*>(
               &_DateRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DateRange& a, DateRange& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DateRange* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DateRange* New() const final {
    return CreateMaybeMessage<DateRange>(nullptr);
  }

  DateRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DateRange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DateRange& from);
  void MergeFrom(const DateRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DateRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.DateRange";
  }
  protected:
  explicit DateRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.DateRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class GenericSet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.GenericSet) */ {
 public:
  inline GenericSet() : GenericSet(nullptr) {}
  virtual ~GenericSet();

  GenericSet(const GenericSet& from);
  GenericSet(GenericSet&& from) noexcept
    : GenericSet() {
    *this = ::std::move(from);
  }

  inline GenericSet& operator=(const GenericSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericSet& operator=(GenericSet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const GenericSet& default_instance();

  static inline const GenericSet* internal_default_instance() {
    return reinterpret_cast<const GenericSet*>(
               &_GenericSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GenericSet& a, GenericSet& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GenericSet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericSet* New() const final {
    return CreateMaybeMessage<GenericSet>(nullptr);
  }

  GenericSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericSet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GenericSet& from);
  void MergeFrom(const GenericSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.GenericSet";
  }
  protected:
  explicit GenericSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.GenericSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class RelatedEventSet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.RelatedEventSet) */ {
 public:
  inline RelatedEventSet() : RelatedEventSet(nullptr) {}
  virtual ~RelatedEventSet();

  RelatedEventSet(const RelatedEventSet& from);
  RelatedEventSet(RelatedEventSet&& from) noexcept
    : RelatedEventSet() {
    *this = ::std::move(from);
  }

  inline RelatedEventSet& operator=(const RelatedEventSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelatedEventSet& operator=(RelatedEventSet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelatedEventSet& default_instance();

  static inline const RelatedEventSet* internal_default_instance() {
    return reinterpret_cast<const RelatedEventSet*>(
               &_RelatedEventSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RelatedEventSet& a, RelatedEventSet& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RelatedEventSet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelatedEventSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelatedEventSet* New() const final {
    return CreateMaybeMessage<RelatedEventSet>(nullptr);
  }

  RelatedEventSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelatedEventSet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RelatedEventSet& from);
  void MergeFrom(const RelatedEventSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelatedEventSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.RelatedEventSet";
  }
  protected:
  explicit RelatedEventSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.RelatedEventSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class RelatedNameMap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.RelatedNameMap) */ {
 public:
  inline RelatedNameMap() : RelatedNameMap(nullptr) {}
  virtual ~RelatedNameMap();

  RelatedNameMap(const RelatedNameMap& from);
  RelatedNameMap(RelatedNameMap&& from) noexcept
    : RelatedNameMap() {
    *this = ::std::move(from);
  }

  inline RelatedNameMap& operator=(const RelatedNameMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelatedNameMap& operator=(RelatedNameMap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelatedNameMap& default_instance();

  static inline const RelatedNameMap* internal_default_instance() {
    return reinterpret_cast<const RelatedNameMap*>(
               &_RelatedNameMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RelatedNameMap& a, RelatedNameMap& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RelatedNameMap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelatedNameMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelatedNameMap* New() const final {
    return CreateMaybeMessage<RelatedNameMap>(nullptr);
  }

  RelatedNameMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelatedNameMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RelatedNameMap& from);
  void MergeFrom(const RelatedNameMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelatedNameMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.RelatedNameMap";
  }
  protected:
  explicit RelatedNameMap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.RelatedNameMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Scalar PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Scalar) */ {
 public:
  inline Scalar() : Scalar(nullptr) {}
  virtual ~Scalar();

  Scalar(const Scalar& from);
  Scalar(Scalar&& from) noexcept
    : Scalar() {
    *this = ::std::move(from);
  }

  inline Scalar& operator=(const Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scalar& operator=(Scalar&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Scalar& default_instance();

  static inline const Scalar* internal_default_instance() {
    return reinterpret_cast<const Scalar*>(
               &_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Scalar& a, Scalar& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Scalar* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scalar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Scalar* New() const final {
    return CreateMaybeMessage<Scalar>(nullptr);
  }

  Scalar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Scalar>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Scalar& from);
  void MergeFrom(const Scalar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Scalar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Scalar";
  }
  protected:
  explicit Scalar(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Scalar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Diagnostic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Diagnostic) */ {
 public:
  inline Diagnostic() : Diagnostic(nullptr) {}
  virtual ~Diagnostic();

  Diagnostic(const Diagnostic& from);
  Diagnostic(Diagnostic&& from) noexcept
    : Diagnostic() {
    *this = ::std::move(from);
  }

  inline Diagnostic& operator=(const Diagnostic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Diagnostic& operator=(Diagnostic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Diagnostic& default_instance();

  enum DiagnosticOneofCase {
    kBreakdown = 1,
    kDateRange = 2,
    kGenericSet = 3,
    kRelatedEventSet = 4,
    kRelatedNameMap = 5,
    kScalar = 6,
    kSharedDiagnosticGuid = 7,
    DIAGNOSTIC_ONEOF_NOT_SET = 0,
  };

  static inline const Diagnostic* internal_default_instance() {
    return reinterpret_cast<const Diagnostic*>(
               &_Diagnostic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Diagnostic& a, Diagnostic& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Diagnostic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Diagnostic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Diagnostic* New() const final {
    return CreateMaybeMessage<Diagnostic>(nullptr);
  }

  Diagnostic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Diagnostic>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Diagnostic& from);
  void MergeFrom(const Diagnostic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Diagnostic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Diagnostic";
  }
  protected:
  explicit Diagnostic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBreakdownFieldNumber = 1,
    kDateRangeFieldNumber = 2,
    kGenericSetFieldNumber = 3,
    kRelatedEventSetFieldNumber = 4,
    kRelatedNameMapFieldNumber = 5,
    kScalarFieldNumber = 6,
    kSharedDiagnosticGuidFieldNumber = 7,
  };
  // .catapult.tracing.tracing.proto.Breakdown breakdown = 1;
  bool has_breakdown() const;
  private:
  bool _internal_has_breakdown() const;
  public:
  void clear_breakdown();
  const ::catapult::tracing::tracing::proto::Breakdown& breakdown() const;
  ::catapult::tracing::tracing::proto::Breakdown* release_breakdown();
  ::catapult::tracing::tracing::proto::Breakdown* mutable_breakdown();
  void set_allocated_breakdown(::catapult::tracing::tracing::proto::Breakdown* breakdown);
  private:
  const ::catapult::tracing::tracing::proto::Breakdown& _internal_breakdown() const;
  ::catapult::tracing::tracing::proto::Breakdown* _internal_mutable_breakdown();
  public:
  void unsafe_arena_set_allocated_breakdown(
      ::catapult::tracing::tracing::proto::Breakdown* breakdown);
  ::catapult::tracing::tracing::proto::Breakdown* unsafe_arena_release_breakdown();

  // .catapult.tracing.tracing.proto.DateRange date_range = 2;
  bool has_date_range() const;
  private:
  bool _internal_has_date_range() const;
  public:
  void clear_date_range();
  const ::catapult::tracing::tracing::proto::DateRange& date_range() const;
  ::catapult::tracing::tracing::proto::DateRange* release_date_range();
  ::catapult::tracing::tracing::proto::DateRange* mutable_date_range();
  void set_allocated_date_range(::catapult::tracing::tracing::proto::DateRange* date_range);
  private:
  const ::catapult::tracing::tracing::proto::DateRange& _internal_date_range() const;
  ::catapult::tracing::tracing::proto::DateRange* _internal_mutable_date_range();
  public:
  void unsafe_arena_set_allocated_date_range(
      ::catapult::tracing::tracing::proto::DateRange* date_range);
  ::catapult::tracing::tracing::proto::DateRange* unsafe_arena_release_date_range();

  // .catapult.tracing.tracing.proto.GenericSet generic_set = 3;
  bool has_generic_set() const;
  private:
  bool _internal_has_generic_set() const;
  public:
  void clear_generic_set();
  const ::catapult::tracing::tracing::proto::GenericSet& generic_set() const;
  ::catapult::tracing::tracing::proto::GenericSet* release_generic_set();
  ::catapult::tracing::tracing::proto::GenericSet* mutable_generic_set();
  void set_allocated_generic_set(::catapult::tracing::tracing::proto::GenericSet* generic_set);
  private:
  const ::catapult::tracing::tracing::proto::GenericSet& _internal_generic_set() const;
  ::catapult::tracing::tracing::proto::GenericSet* _internal_mutable_generic_set();
  public:
  void unsafe_arena_set_allocated_generic_set(
      ::catapult::tracing::tracing::proto::GenericSet* generic_set);
  ::catapult::tracing::tracing::proto::GenericSet* unsafe_arena_release_generic_set();

  // .catapult.tracing.tracing.proto.RelatedEventSet related_event_set = 4;
  bool has_related_event_set() const;
  private:
  bool _internal_has_related_event_set() const;
  public:
  void clear_related_event_set();
  const ::catapult::tracing::tracing::proto::RelatedEventSet& related_event_set() const;
  ::catapult::tracing::tracing::proto::RelatedEventSet* release_related_event_set();
  ::catapult::tracing::tracing::proto::RelatedEventSet* mutable_related_event_set();
  void set_allocated_related_event_set(::catapult::tracing::tracing::proto::RelatedEventSet* related_event_set);
  private:
  const ::catapult::tracing::tracing::proto::RelatedEventSet& _internal_related_event_set() const;
  ::catapult::tracing::tracing::proto::RelatedEventSet* _internal_mutable_related_event_set();
  public:
  void unsafe_arena_set_allocated_related_event_set(
      ::catapult::tracing::tracing::proto::RelatedEventSet* related_event_set);
  ::catapult::tracing::tracing::proto::RelatedEventSet* unsafe_arena_release_related_event_set();

  // .catapult.tracing.tracing.proto.RelatedNameMap related_name_map = 5;
  bool has_related_name_map() const;
  private:
  bool _internal_has_related_name_map() const;
  public:
  void clear_related_name_map();
  const ::catapult::tracing::tracing::proto::RelatedNameMap& related_name_map() const;
  ::catapult::tracing::tracing::proto::RelatedNameMap* release_related_name_map();
  ::catapult::tracing::tracing::proto::RelatedNameMap* mutable_related_name_map();
  void set_allocated_related_name_map(::catapult::tracing::tracing::proto::RelatedNameMap* related_name_map);
  private:
  const ::catapult::tracing::tracing::proto::RelatedNameMap& _internal_related_name_map() const;
  ::catapult::tracing::tracing::proto::RelatedNameMap* _internal_mutable_related_name_map();
  public:
  void unsafe_arena_set_allocated_related_name_map(
      ::catapult::tracing::tracing::proto::RelatedNameMap* related_name_map);
  ::catapult::tracing::tracing::proto::RelatedNameMap* unsafe_arena_release_related_name_map();

  // .catapult.tracing.tracing.proto.Scalar scalar = 6;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;
  public:
  void clear_scalar();
  const ::catapult::tracing::tracing::proto::Scalar& scalar() const;
  ::catapult::tracing::tracing::proto::Scalar* release_scalar();
  ::catapult::tracing::tracing::proto::Scalar* mutable_scalar();
  void set_allocated_scalar(::catapult::tracing::tracing::proto::Scalar* scalar);
  private:
  const ::catapult::tracing::tracing::proto::Scalar& _internal_scalar() const;
  ::catapult::tracing::tracing::proto::Scalar* _internal_mutable_scalar();
  public:
  void unsafe_arena_set_allocated_scalar(
      ::catapult::tracing::tracing::proto::Scalar* scalar);
  ::catapult::tracing::tracing::proto::Scalar* unsafe_arena_release_scalar();

  // string shared_diagnostic_guid = 7;
  private:
  bool _internal_has_shared_diagnostic_guid() const;
  public:
  void clear_shared_diagnostic_guid();
  const std::string& shared_diagnostic_guid() const;
  void set_shared_diagnostic_guid(const std::string& value);
  void set_shared_diagnostic_guid(std::string&& value);
  void set_shared_diagnostic_guid(const char* value);
  void set_shared_diagnostic_guid(const char* value, size_t size);
  std::string* mutable_shared_diagnostic_guid();
  std::string* release_shared_diagnostic_guid();
  void set_allocated_shared_diagnostic_guid(std::string* shared_diagnostic_guid);
  private:
  const std::string& _internal_shared_diagnostic_guid() const;
  void _internal_set_shared_diagnostic_guid(const std::string& value);
  std::string* _internal_mutable_shared_diagnostic_guid();
  public:

  void clear_diagnostic_oneof();
  DiagnosticOneofCase diagnostic_oneof_case() const;
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Diagnostic)
 private:
  class _Internal;
  void set_has_breakdown();
  void set_has_date_range();
  void set_has_generic_set();
  void set_has_related_event_set();
  void set_has_related_name_map();
  void set_has_scalar();
  void set_has_shared_diagnostic_guid();

  inline bool has_diagnostic_oneof() const;
  inline void clear_has_diagnostic_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DiagnosticOneofUnion {
    DiagnosticOneofUnion() {}
    ::catapult::tracing::tracing::proto::Breakdown* breakdown_;
    ::catapult::tracing::tracing::proto::DateRange* date_range_;
    ::catapult::tracing::tracing::proto::GenericSet* generic_set_;
    ::catapult::tracing::tracing::proto::RelatedEventSet* related_event_set_;
    ::catapult::tracing::tracing::proto::RelatedNameMap* related_name_map_;
    ::catapult::tracing::tracing::proto::Scalar* scalar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shared_diagnostic_guid_;
  } diagnostic_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class DiagnosticMap_DiagnosticMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<DiagnosticMap_DiagnosticMapEntry_DoNotUse, 
    std::string, ::catapult::tracing::tracing::proto::Diagnostic,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<DiagnosticMap_DiagnosticMapEntry_DoNotUse, 
    std::string, ::catapult::tracing::tracing::proto::Diagnostic,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  DiagnosticMap_DiagnosticMapEntry_DoNotUse();
  explicit DiagnosticMap_DiagnosticMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DiagnosticMap_DiagnosticMapEntry_DoNotUse& other);
  static const DiagnosticMap_DiagnosticMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DiagnosticMap_DiagnosticMapEntry_DoNotUse*>(&_DiagnosticMap_DiagnosticMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "catapult.tracing.tracing.proto.DiagnosticMap.DiagnosticMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class DiagnosticMap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.DiagnosticMap) */ {
 public:
  inline DiagnosticMap() : DiagnosticMap(nullptr) {}
  virtual ~DiagnosticMap();

  DiagnosticMap(const DiagnosticMap& from);
  DiagnosticMap(DiagnosticMap&& from) noexcept
    : DiagnosticMap() {
    *this = ::std::move(from);
  }

  inline DiagnosticMap& operator=(const DiagnosticMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiagnosticMap& operator=(DiagnosticMap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DiagnosticMap& default_instance();

  static inline const DiagnosticMap* internal_default_instance() {
    return reinterpret_cast<const DiagnosticMap*>(
               &_DiagnosticMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DiagnosticMap& a, DiagnosticMap& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DiagnosticMap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiagnosticMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiagnosticMap* New() const final {
    return CreateMaybeMessage<DiagnosticMap>(nullptr);
  }

  DiagnosticMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiagnosticMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DiagnosticMap& from);
  void MergeFrom(const DiagnosticMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DiagnosticMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.DiagnosticMap";
  }
  protected:
  explicit DiagnosticMap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDiagnosticMapFieldNumber = 1,
  };
  // map<string, .catapult.tracing.tracing.proto.Diagnostic> diagnostic_map = 1;
  int diagnostic_map_size() const;
  private:
  int _internal_diagnostic_map_size() const;
  public:
  void clear_diagnostic_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
      _internal_diagnostic_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
      _internal_mutable_diagnostic_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
      diagnostic_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
      mutable_diagnostic_map();

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.DiagnosticMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      DiagnosticMap_DiagnosticMapEntry_DoNotUse,
      std::string, ::catapult::tracing::tracing::proto::Diagnostic,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> diagnostic_map_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class RunningStatistics PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.RunningStatistics) */ {
 public:
  inline RunningStatistics() : RunningStatistics(nullptr) {}
  virtual ~RunningStatistics();

  RunningStatistics(const RunningStatistics& from);
  RunningStatistics(RunningStatistics&& from) noexcept
    : RunningStatistics() {
    *this = ::std::move(from);
  }

  inline RunningStatistics& operator=(const RunningStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunningStatistics& operator=(RunningStatistics&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RunningStatistics& default_instance();

  static inline const RunningStatistics* internal_default_instance() {
    return reinterpret_cast<const RunningStatistics*>(
               &_RunningStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RunningStatistics& a, RunningStatistics& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RunningStatistics* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunningStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunningStatistics* New() const final {
    return CreateMaybeMessage<RunningStatistics>(nullptr);
  }

  RunningStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunningStatistics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RunningStatistics& from);
  void MergeFrom(const RunningStatistics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunningStatistics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.RunningStatistics";
  }
  protected:
  explicit RunningStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxFieldNumber = 2,
    kMeanlogsFieldNumber = 3,
    kMeanFieldNumber = 4,
    kMinFieldNumber = 5,
    kSumFieldNumber = 6,
    kVarianceFieldNumber = 7,
    kCountFieldNumber = 1,
  };
  // double max = 2;
  void clear_max();
  double max() const;
  void set_max(double value);
  private:
  double _internal_max() const;
  void _internal_set_max(double value);
  public:

  // double meanlogs = 3;
  void clear_meanlogs();
  double meanlogs() const;
  void set_meanlogs(double value);
  private:
  double _internal_meanlogs() const;
  void _internal_set_meanlogs(double value);
  public:

  // double mean = 4;
  void clear_mean();
  double mean() const;
  void set_mean(double value);
  private:
  double _internal_mean() const;
  void _internal_set_mean(double value);
  public:

  // double min = 5;
  void clear_min();
  double min() const;
  void set_min(double value);
  private:
  double _internal_min() const;
  void _internal_set_min(double value);
  public:

  // double sum = 6;
  void clear_sum();
  double sum() const;
  void set_sum(double value);
  private:
  double _internal_sum() const;
  void _internal_set_sum(double value);
  public:

  // double variance = 7;
  void clear_variance();
  double variance() const;
  void set_variance(double value);
  private:
  double _internal_variance() const;
  void _internal_set_variance(double value);
  public:

  // int32 count = 1;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.RunningStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double max_;
  double meanlogs_;
  double mean_;
  double min_;
  double sum_;
  double variance_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Bin PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Bin) */ {
 public:
  inline Bin() : Bin(nullptr) {}
  virtual ~Bin();

  Bin(const Bin& from);
  Bin(Bin&& from) noexcept
    : Bin() {
    *this = ::std::move(from);
  }

  inline Bin& operator=(const Bin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bin& operator=(Bin&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Bin& default_instance();

  static inline const Bin* internal_default_instance() {
    return reinterpret_cast<const Bin*>(
               &_Bin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Bin& a, Bin& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Bin* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bin* New() const final {
    return CreateMaybeMessage<Bin>(nullptr);
  }

  Bin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Bin& from);
  void MergeFrom(const Bin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Bin";
  }
  protected:
  explicit Bin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiagnosticMapsFieldNumber = 2,
    kBinCountFieldNumber = 1,
  };
  // repeated .catapult.tracing.tracing.proto.DiagnosticMap diagnostic_maps = 2;
  int diagnostic_maps_size() const;
  private:
  int _internal_diagnostic_maps_size() const;
  public:
  void clear_diagnostic_maps();
  ::catapult::tracing::tracing::proto::DiagnosticMap* mutable_diagnostic_maps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >*
      mutable_diagnostic_maps();
  private:
  const ::catapult::tracing::tracing::proto::DiagnosticMap& _internal_diagnostic_maps(int index) const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* _internal_add_diagnostic_maps();
  public:
  const ::catapult::tracing::tracing::proto::DiagnosticMap& diagnostic_maps(int index) const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* add_diagnostic_maps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >&
      diagnostic_maps() const;

  // int32 bin_count = 1;
  void clear_bin_count();
  ::PROTOBUF_NAMESPACE_ID::int32 bin_count() const;
  void set_bin_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bin_count() const;
  void _internal_set_bin_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Bin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap > diagnostic_maps_;
  ::PROTOBUF_NAMESPACE_ID::int32 bin_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class SummaryOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.SummaryOptions) */ {
 public:
  inline SummaryOptions() : SummaryOptions(nullptr) {}
  virtual ~SummaryOptions();

  SummaryOptions(const SummaryOptions& from);
  SummaryOptions(SummaryOptions&& from) noexcept
    : SummaryOptions() {
    *this = ::std::move(from);
  }

  inline SummaryOptions& operator=(const SummaryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SummaryOptions& operator=(SummaryOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SummaryOptions& default_instance();

  static inline const SummaryOptions* internal_default_instance() {
    return reinterpret_cast<const SummaryOptions*>(
               &_SummaryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SummaryOptions& a, SummaryOptions& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SummaryOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SummaryOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SummaryOptions* New() const final {
    return CreateMaybeMessage<SummaryOptions>(nullptr);
  }

  SummaryOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SummaryOptions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SummaryOptions& from);
  void MergeFrom(const SummaryOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SummaryOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.SummaryOptions";
  }
  protected:
  explicit SummaryOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentileFieldNumber = 9,
    kAvgFieldNumber = 1,
    kGeometricMeanFieldNumber = 2,
    kStdFieldNumber = 3,
    kCountFieldNumber = 4,
    kSumFieldNumber = 5,
    kMinFieldNumber = 6,
    kMaxFieldNumber = 7,
    kNansFieldNumber = 8,
  };
  // repeated float percentile = 9;
  int percentile_size() const;
  private:
  int _internal_percentile_size() const;
  public:
  void clear_percentile();
  private:
  float _internal_percentile(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_percentile() const;
  void _internal_add_percentile(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_percentile();
  public:
  float percentile(int index) const;
  void set_percentile(int index, float value);
  void add_percentile(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      percentile() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_percentile();

  // bool avg = 1;
  void clear_avg();
  bool avg() const;
  void set_avg(bool value);
  private:
  bool _internal_avg() const;
  void _internal_set_avg(bool value);
  public:

  // bool geometric_mean = 2;
  void clear_geometric_mean();
  bool geometric_mean() const;
  void set_geometric_mean(bool value);
  private:
  bool _internal_geometric_mean() const;
  void _internal_set_geometric_mean(bool value);
  public:

  // bool std = 3;
  void clear_std();
  bool std() const;
  void set_std(bool value);
  private:
  bool _internal_std() const;
  void _internal_set_std(bool value);
  public:

  // bool count = 4;
  void clear_count();
  bool count() const;
  void set_count(bool value);
  private:
  bool _internal_count() const;
  void _internal_set_count(bool value);
  public:

  // bool sum = 5;
  void clear_sum();
  bool sum() const;
  void set_sum(bool value);
  private:
  bool _internal_sum() const;
  void _internal_set_sum(bool value);
  public:

  // bool min = 6;
  void clear_min();
  bool min() const;
  void set_min(bool value);
  private:
  bool _internal_min() const;
  void _internal_set_min(bool value);
  public:

  // bool max = 7;
  void clear_max();
  bool max() const;
  void set_max(bool value);
  private:
  bool _internal_max() const;
  void _internal_set_max(bool value);
  public:

  // bool nans = 8;
  void clear_nans();
  bool nans() const;
  void set_nans(bool value);
  private:
  bool _internal_nans() const;
  void _internal_set_nans(bool value);
  public:

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.SummaryOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > percentile_;
  mutable std::atomic<int> _percentile_cached_byte_size_;
  bool avg_;
  bool geometric_mean_;
  bool std_;
  bool count_;
  bool sum_;
  bool min_;
  bool max_;
  bool nans_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Histogram_AllBinsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Histogram_AllBinsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Histogram_AllBinsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Histogram_AllBinsEntry_DoNotUse();
  explicit Histogram_AllBinsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Histogram_AllBinsEntry_DoNotUse& other);
  static const Histogram_AllBinsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Histogram_AllBinsEntry_DoNotUse*>(&_Histogram_AllBinsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Histogram PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Histogram) */ {
 public:
  inline Histogram() : Histogram(nullptr) {}
  virtual ~Histogram();

  Histogram(const Histogram& from);
  Histogram(Histogram&& from) noexcept
    : Histogram() {
    *this = ::std::move(from);
  }

  inline Histogram& operator=(const Histogram& from) {
    CopyFrom(from);
    return *this;
  }
  inline Histogram& operator=(Histogram&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Histogram& default_instance();

  static inline const Histogram* internal_default_instance() {
    return reinterpret_cast<const Histogram*>(
               &_Histogram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Histogram& a, Histogram& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Histogram* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Histogram* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Histogram* New() const final {
    return CreateMaybeMessage<Histogram>(nullptr);
  }

  Histogram* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Histogram>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Histogram& from);
  void MergeFrom(const Histogram& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Histogram* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Histogram";
  }
  protected:
  explicit Histogram(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSampleValuesFieldNumber = 6,
    kNanDiagnosticsFieldNumber = 9,
    kAllBinsFieldNumber = 11,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 4,
    kUnitFieldNumber = 2,
    kBinBoundariesFieldNumber = 3,
    kDiagnosticsFieldNumber = 5,
    kRunningFieldNumber = 10,
    kSummaryOptionsFieldNumber = 12,
    kMaxNumSampleValuesFieldNumber = 7,
    kNumNansFieldNumber = 8,
  };
  // repeated double sample_values = 6;
  int sample_values_size() const;
  private:
  int _internal_sample_values_size() const;
  public:
  void clear_sample_values();
  private:
  double _internal_sample_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_sample_values() const;
  void _internal_add_sample_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_sample_values();
  public:
  double sample_values(int index) const;
  void set_sample_values(int index, double value);
  void add_sample_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      sample_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_sample_values();

  // repeated .catapult.tracing.tracing.proto.DiagnosticMap nan_diagnostics = 9;
  int nan_diagnostics_size() const;
  private:
  int _internal_nan_diagnostics_size() const;
  public:
  void clear_nan_diagnostics();
  ::catapult::tracing::tracing::proto::DiagnosticMap* mutable_nan_diagnostics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >*
      mutable_nan_diagnostics();
  private:
  const ::catapult::tracing::tracing::proto::DiagnosticMap& _internal_nan_diagnostics(int index) const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* _internal_add_nan_diagnostics();
  public:
  const ::catapult::tracing::tracing::proto::DiagnosticMap& nan_diagnostics(int index) const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* add_nan_diagnostics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >&
      nan_diagnostics() const;

  // map<int32, .catapult.tracing.tracing.proto.Bin> all_bins = 11;
  int all_bins_size() const;
  private:
  int _internal_all_bins_size() const;
  public:
  void clear_all_bins();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >&
      _internal_all_bins() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >*
      _internal_mutable_all_bins();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >&
      all_bins() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >*
      mutable_all_bins();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .catapult.tracing.tracing.proto.UnitAndDirection unit = 2;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  const ::catapult::tracing::tracing::proto::UnitAndDirection& unit() const;
  ::catapult::tracing::tracing::proto::UnitAndDirection* release_unit();
  ::catapult::tracing::tracing::proto::UnitAndDirection* mutable_unit();
  void set_allocated_unit(::catapult::tracing::tracing::proto::UnitAndDirection* unit);
  private:
  const ::catapult::tracing::tracing::proto::UnitAndDirection& _internal_unit() const;
  ::catapult::tracing::tracing::proto::UnitAndDirection* _internal_mutable_unit();
  public:
  void unsafe_arena_set_allocated_unit(
      ::catapult::tracing::tracing::proto::UnitAndDirection* unit);
  ::catapult::tracing::tracing::proto::UnitAndDirection* unsafe_arena_release_unit();

  // .catapult.tracing.tracing.proto.BinBoundaries bin_boundaries = 3;
  bool has_bin_boundaries() const;
  private:
  bool _internal_has_bin_boundaries() const;
  public:
  void clear_bin_boundaries();
  const ::catapult::tracing::tracing::proto::BinBoundaries& bin_boundaries() const;
  ::catapult::tracing::tracing::proto::BinBoundaries* release_bin_boundaries();
  ::catapult::tracing::tracing::proto::BinBoundaries* mutable_bin_boundaries();
  void set_allocated_bin_boundaries(::catapult::tracing::tracing::proto::BinBoundaries* bin_boundaries);
  private:
  const ::catapult::tracing::tracing::proto::BinBoundaries& _internal_bin_boundaries() const;
  ::catapult::tracing::tracing::proto::BinBoundaries* _internal_mutable_bin_boundaries();
  public:
  void unsafe_arena_set_allocated_bin_boundaries(
      ::catapult::tracing::tracing::proto::BinBoundaries* bin_boundaries);
  ::catapult::tracing::tracing::proto::BinBoundaries* unsafe_arena_release_bin_boundaries();

  // .catapult.tracing.tracing.proto.DiagnosticMap diagnostics = 5;
  bool has_diagnostics() const;
  private:
  bool _internal_has_diagnostics() const;
  public:
  void clear_diagnostics();
  const ::catapult::tracing::tracing::proto::DiagnosticMap& diagnostics() const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* release_diagnostics();
  ::catapult::tracing::tracing::proto::DiagnosticMap* mutable_diagnostics();
  void set_allocated_diagnostics(::catapult::tracing::tracing::proto::DiagnosticMap* diagnostics);
  private:
  const ::catapult::tracing::tracing::proto::DiagnosticMap& _internal_diagnostics() const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* _internal_mutable_diagnostics();
  public:
  void unsafe_arena_set_allocated_diagnostics(
      ::catapult::tracing::tracing::proto::DiagnosticMap* diagnostics);
  ::catapult::tracing::tracing::proto::DiagnosticMap* unsafe_arena_release_diagnostics();

  // .catapult.tracing.tracing.proto.RunningStatistics running = 10;
  bool has_running() const;
  private:
  bool _internal_has_running() const;
  public:
  void clear_running();
  const ::catapult::tracing::tracing::proto::RunningStatistics& running() const;
  ::catapult::tracing::tracing::proto::RunningStatistics* release_running();
  ::catapult::tracing::tracing::proto::RunningStatistics* mutable_running();
  void set_allocated_running(::catapult::tracing::tracing::proto::RunningStatistics* running);
  private:
  const ::catapult::tracing::tracing::proto::RunningStatistics& _internal_running() const;
  ::catapult::tracing::tracing::proto::RunningStatistics* _internal_mutable_running();
  public:
  void unsafe_arena_set_allocated_running(
      ::catapult::tracing::tracing::proto::RunningStatistics* running);
  ::catapult::tracing::tracing::proto::RunningStatistics* unsafe_arena_release_running();

  // .catapult.tracing.tracing.proto.SummaryOptions summary_options = 12;
  bool has_summary_options() const;
  private:
  bool _internal_has_summary_options() const;
  public:
  void clear_summary_options();
  const ::catapult::tracing::tracing::proto::SummaryOptions& summary_options() const;
  ::catapult::tracing::tracing::proto::SummaryOptions* release_summary_options();
  ::catapult::tracing::tracing::proto::SummaryOptions* mutable_summary_options();
  void set_allocated_summary_options(::catapult::tracing::tracing::proto::SummaryOptions* summary_options);
  private:
  const ::catapult::tracing::tracing::proto::SummaryOptions& _internal_summary_options() const;
  ::catapult::tracing::tracing::proto::SummaryOptions* _internal_mutable_summary_options();
  public:
  void unsafe_arena_set_allocated_summary_options(
      ::catapult::tracing::tracing::proto::SummaryOptions* summary_options);
  ::catapult::tracing::tracing::proto::SummaryOptions* unsafe_arena_release_summary_options();

  // int32 max_num_sample_values = 7;
  void clear_max_num_sample_values();
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_sample_values() const;
  void set_max_num_sample_values(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_num_sample_values() const;
  void _internal_set_max_num_sample_values(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_nans = 8;
  void clear_num_nans();
  ::PROTOBUF_NAMESPACE_ID::int32 num_nans() const;
  void set_num_nans(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_nans() const;
  void _internal_set_num_nans(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Histogram)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > sample_values_;
  mutable std::atomic<int> _sample_values_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap > nan_diagnostics_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Histogram_AllBinsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> all_bins_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::catapult::tracing::tracing::proto::UnitAndDirection* unit_;
  ::catapult::tracing::tracing::proto::BinBoundaries* bin_boundaries_;
  ::catapult::tracing::tracing::proto::DiagnosticMap* diagnostics_;
  ::catapult::tracing::tracing::proto::RunningStatistics* running_;
  ::catapult::tracing::tracing::proto::SummaryOptions* summary_options_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_sample_values_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_nans_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class HistogramSet_SharedDiagnosticsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<HistogramSet_SharedDiagnosticsEntry_DoNotUse, 
    std::string, ::catapult::tracing::tracing::proto::Diagnostic,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<HistogramSet_SharedDiagnosticsEntry_DoNotUse, 
    std::string, ::catapult::tracing::tracing::proto::Diagnostic,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  HistogramSet_SharedDiagnosticsEntry_DoNotUse();
  explicit HistogramSet_SharedDiagnosticsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HistogramSet_SharedDiagnosticsEntry_DoNotUse& other);
  static const HistogramSet_SharedDiagnosticsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HistogramSet_SharedDiagnosticsEntry_DoNotUse*>(&_HistogramSet_SharedDiagnosticsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "catapult.tracing.tracing.proto.HistogramSet.SharedDiagnosticsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class HistogramSet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.HistogramSet) */ {
 public:
  inline HistogramSet() : HistogramSet(nullptr) {}
  virtual ~HistogramSet();

  HistogramSet(const HistogramSet& from);
  HistogramSet(HistogramSet&& from) noexcept
    : HistogramSet() {
    *this = ::std::move(from);
  }

  inline HistogramSet& operator=(const HistogramSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistogramSet& operator=(HistogramSet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HistogramSet& default_instance();

  static inline const HistogramSet* internal_default_instance() {
    return reinterpret_cast<const HistogramSet*>(
               &_HistogramSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(HistogramSet& a, HistogramSet& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(HistogramSet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistogramSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HistogramSet* New() const final {
    return CreateMaybeMessage<HistogramSet>(nullptr);
  }

  HistogramSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HistogramSet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HistogramSet& from);
  void MergeFrom(const HistogramSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HistogramSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.HistogramSet";
  }
  protected:
  explicit HistogramSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHistogramsFieldNumber = 1,
    kSharedDiagnosticsFieldNumber = 2,
  };
  // repeated .catapult.tracing.tracing.proto.Histogram histograms = 1;
  int histograms_size() const;
  private:
  int _internal_histograms_size() const;
  public:
  void clear_histograms();
  ::catapult::tracing::tracing::proto::Histogram* mutable_histograms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram >*
      mutable_histograms();
  private:
  const ::catapult::tracing::tracing::proto::Histogram& _internal_histograms(int index) const;
  ::catapult::tracing::tracing::proto::Histogram* _internal_add_histograms();
  public:
  const ::catapult::tracing::tracing::proto::Histogram& histograms(int index) const;
  ::catapult::tracing::tracing::proto::Histogram* add_histograms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram >&
      histograms() const;

  // map<string, .catapult.tracing.tracing.proto.Diagnostic> shared_diagnostics = 2;
  int shared_diagnostics_size() const;
  private:
  int _internal_shared_diagnostics_size() const;
  public:
  void clear_shared_diagnostics();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
      _internal_shared_diagnostics() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
      _internal_mutable_shared_diagnostics();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
      shared_diagnostics() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
      mutable_shared_diagnostics();

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.HistogramSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram > histograms_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      HistogramSet_SharedDiagnosticsEntry_DoNotUse,
      std::string, ::catapult::tracing::tracing::proto::Diagnostic,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> shared_diagnostics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UnitAndDirection

// .catapult.tracing.tracing.proto.Unit unit = 1;
inline void UnitAndDirection::clear_unit() {
  unit_ = 0;
}
inline ::catapult::tracing::tracing::proto::Unit UnitAndDirection::_internal_unit() const {
  return static_cast< ::catapult::tracing::tracing::proto::Unit >(unit_);
}
inline ::catapult::tracing::tracing::proto::Unit UnitAndDirection::unit() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.UnitAndDirection.unit)
  return _internal_unit();
}
inline void UnitAndDirection::_internal_set_unit(::catapult::tracing::tracing::proto::Unit value) {
  
  unit_ = value;
}
inline void UnitAndDirection::set_unit(::catapult::tracing::tracing::proto::Unit value) {
  _internal_set_unit(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.UnitAndDirection.unit)
}

// .catapult.tracing.tracing.proto.ImprovementDirection improvement_direction = 2;
inline void UnitAndDirection::clear_improvement_direction() {
  improvement_direction_ = 0;
}
inline ::catapult::tracing::tracing::proto::ImprovementDirection UnitAndDirection::_internal_improvement_direction() const {
  return static_cast< ::catapult::tracing::tracing::proto::ImprovementDirection >(improvement_direction_);
}
inline ::catapult::tracing::tracing::proto::ImprovementDirection UnitAndDirection::improvement_direction() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.UnitAndDirection.improvement_direction)
  return _internal_improvement_direction();
}
inline void UnitAndDirection::_internal_set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value) {
  
  improvement_direction_ = value;
}
inline void UnitAndDirection::set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value) {
  _internal_set_improvement_direction(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.UnitAndDirection.improvement_direction)
}

// -------------------------------------------------------------------

// BinBoundaryDetailedSpec

// .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.Type boundary_type = 1;
inline void BinBoundaryDetailedSpec::clear_boundary_type() {
  boundary_type_ = 0;
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec::_internal_boundary_type() const {
  return static_cast< ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type >(boundary_type_);
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec::boundary_type() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.boundary_type)
  return _internal_boundary_type();
}
inline void BinBoundaryDetailedSpec::_internal_set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value) {
  
  boundary_type_ = value;
}
inline void BinBoundaryDetailedSpec::set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value) {
  _internal_set_boundary_type(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.boundary_type)
}

// double maximum_bin_boundary = 2;
inline void BinBoundaryDetailedSpec::clear_maximum_bin_boundary() {
  maximum_bin_boundary_ = 0;
}
inline double BinBoundaryDetailedSpec::_internal_maximum_bin_boundary() const {
  return maximum_bin_boundary_;
}
inline double BinBoundaryDetailedSpec::maximum_bin_boundary() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.maximum_bin_boundary)
  return _internal_maximum_bin_boundary();
}
inline void BinBoundaryDetailedSpec::_internal_set_maximum_bin_boundary(double value) {
  
  maximum_bin_boundary_ = value;
}
inline void BinBoundaryDetailedSpec::set_maximum_bin_boundary(double value) {
  _internal_set_maximum_bin_boundary(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.maximum_bin_boundary)
}

// int32 num_bin_boundaries = 3;
inline void BinBoundaryDetailedSpec::clear_num_bin_boundaries() {
  num_bin_boundaries_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BinBoundaryDetailedSpec::_internal_num_bin_boundaries() const {
  return num_bin_boundaries_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BinBoundaryDetailedSpec::num_bin_boundaries() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.num_bin_boundaries)
  return _internal_num_bin_boundaries();
}
inline void BinBoundaryDetailedSpec::_internal_set_num_bin_boundaries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_bin_boundaries_ = value;
}
inline void BinBoundaryDetailedSpec::set_num_bin_boundaries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_bin_boundaries(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.num_bin_boundaries)
}

// -------------------------------------------------------------------

// BinBoundarySpec

// double bin_boundary = 1;
inline bool BinBoundarySpec::_internal_has_bin_boundary() const {
  return boundary_oneof_case() == kBinBoundary;
}
inline void BinBoundarySpec::set_has_bin_boundary() {
  _oneof_case_[0] = kBinBoundary;
}
inline void BinBoundarySpec::clear_bin_boundary() {
  if (_internal_has_bin_boundary()) {
    boundary_oneof_.bin_boundary_ = 0;
    clear_has_boundary_oneof();
  }
}
inline double BinBoundarySpec::_internal_bin_boundary() const {
  if (_internal_has_bin_boundary()) {
    return boundary_oneof_.bin_boundary_;
  }
  return 0;
}
inline void BinBoundarySpec::_internal_set_bin_boundary(double value) {
  if (!_internal_has_bin_boundary()) {
    clear_boundary_oneof();
    set_has_bin_boundary();
  }
  boundary_oneof_.bin_boundary_ = value;
}
inline double BinBoundarySpec::bin_boundary() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundarySpec.bin_boundary)
  return _internal_bin_boundary();
}
inline void BinBoundarySpec::set_bin_boundary(double value) {
  _internal_set_bin_boundary(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundarySpec.bin_boundary)
}

// .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec bin_spec = 2;
inline bool BinBoundarySpec::_internal_has_bin_spec() const {
  return boundary_oneof_case() == kBinSpec;
}
inline bool BinBoundarySpec::has_bin_spec() const {
  return _internal_has_bin_spec();
}
inline void BinBoundarySpec::set_has_bin_spec() {
  _oneof_case_[0] = kBinSpec;
}
inline void BinBoundarySpec::clear_bin_spec() {
  if (_internal_has_bin_spec()) {
    if (GetArena() == nullptr) {
      delete boundary_oneof_.bin_spec_;
    }
    clear_has_boundary_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* BinBoundarySpec::release_bin_spec() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  if (_internal_has_bin_spec()) {
    clear_has_boundary_oneof();
      ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* temp = boundary_oneof_.bin_spec_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    boundary_oneof_.bin_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& BinBoundarySpec::_internal_bin_spec() const {
  return _internal_has_bin_spec()
      ? *boundary_oneof_.bin_spec_
      : reinterpret_cast< ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec&>(::catapult::tracing::tracing::proto::_BinBoundaryDetailedSpec_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& BinBoundarySpec::bin_spec() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  return _internal_bin_spec();
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* BinBoundarySpec::unsafe_arena_release_bin_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  if (_internal_has_bin_spec()) {
    clear_has_boundary_oneof();
    ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* temp = boundary_oneof_.bin_spec_;
    boundary_oneof_.bin_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BinBoundarySpec::unsafe_arena_set_allocated_bin_spec(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* bin_spec) {
  clear_boundary_oneof();
  if (bin_spec) {
    set_has_bin_spec();
    boundary_oneof_.bin_spec_ = bin_spec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* BinBoundarySpec::_internal_mutable_bin_spec() {
  if (!_internal_has_bin_spec()) {
    clear_boundary_oneof();
    set_has_bin_spec();
    boundary_oneof_.bin_spec_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec >(GetArena());
  }
  return boundary_oneof_.bin_spec_;
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* BinBoundarySpec::mutable_bin_spec() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  return _internal_mutable_bin_spec();
}

inline bool BinBoundarySpec::has_boundary_oneof() const {
  return boundary_oneof_case() != BOUNDARY_ONEOF_NOT_SET;
}
inline void BinBoundarySpec::clear_has_boundary_oneof() {
  _oneof_case_[0] = BOUNDARY_ONEOF_NOT_SET;
}
inline BinBoundarySpec::BoundaryOneofCase BinBoundarySpec::boundary_oneof_case() const {
  return BinBoundarySpec::BoundaryOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BinBoundaries

// double first_bin_boundary = 1;
inline void BinBoundaries::clear_first_bin_boundary() {
  first_bin_boundary_ = 0;
}
inline double BinBoundaries::_internal_first_bin_boundary() const {
  return first_bin_boundary_;
}
inline double BinBoundaries::first_bin_boundary() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaries.first_bin_boundary)
  return _internal_first_bin_boundary();
}
inline void BinBoundaries::_internal_set_first_bin_boundary(double value) {
  
  first_bin_boundary_ = value;
}
inline void BinBoundaries::set_first_bin_boundary(double value) {
  _internal_set_first_bin_boundary(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaries.first_bin_boundary)
}

// repeated .catapult.tracing.tracing.proto.BinBoundarySpec bin_specs = 2;
inline int BinBoundaries::_internal_bin_specs_size() const {
  return bin_specs_.size();
}
inline int BinBoundaries::bin_specs_size() const {
  return _internal_bin_specs_size();
}
inline void BinBoundaries::clear_bin_specs() {
  bin_specs_.Clear();
}
inline ::catapult::tracing::tracing::proto::BinBoundarySpec* BinBoundaries::mutable_bin_specs(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return bin_specs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec >*
BinBoundaries::mutable_bin_specs() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return &bin_specs_;
}
inline const ::catapult::tracing::tracing::proto::BinBoundarySpec& BinBoundaries::_internal_bin_specs(int index) const {
  return bin_specs_.Get(index);
}
inline const ::catapult::tracing::tracing::proto::BinBoundarySpec& BinBoundaries::bin_specs(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return _internal_bin_specs(index);
}
inline ::catapult::tracing::tracing::proto::BinBoundarySpec* BinBoundaries::_internal_add_bin_specs() {
  return bin_specs_.Add();
}
inline ::catapult::tracing::tracing::proto::BinBoundarySpec* BinBoundaries::add_bin_specs() {
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return _internal_add_bin_specs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec >&
BinBoundaries::bin_specs() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return bin_specs_;
}

// -------------------------------------------------------------------

// Breakdown

// -------------------------------------------------------------------

// DateRange

// -------------------------------------------------------------------

// GenericSet

// repeated string values = 1;
inline int GenericSet::_internal_values_size() const {
  return values_.size();
}
inline int GenericSet::values_size() const {
  return _internal_values_size();
}
inline void GenericSet::clear_values() {
  values_.Clear();
}
inline std::string* GenericSet::add_values() {
  // @@protoc_insertion_point(field_add_mutable:catapult.tracing.tracing.proto.GenericSet.values)
  return _internal_add_values();
}
inline const std::string& GenericSet::_internal_values(int index) const {
  return values_.Get(index);
}
inline const std::string& GenericSet::values(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.GenericSet.values)
  return _internal_values(index);
}
inline std::string* GenericSet::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.GenericSet.values)
  return values_.Mutable(index);
}
inline void GenericSet::set_values(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.GenericSet.values)
  values_.Mutable(index)->assign(value);
}
inline void GenericSet::set_values(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.GenericSet.values)
  values_.Mutable(index)->assign(std::move(value));
}
inline void GenericSet::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:catapult.tracing.tracing.proto.GenericSet.values)
}
inline void GenericSet::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:catapult.tracing.tracing.proto.GenericSet.values)
}
inline std::string* GenericSet::_internal_add_values() {
  return values_.Add();
}
inline void GenericSet::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.GenericSet.values)
}
inline void GenericSet::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.GenericSet.values)
}
inline void GenericSet::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:catapult.tracing.tracing.proto.GenericSet.values)
}
inline void GenericSet::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:catapult.tracing.tracing.proto.GenericSet.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GenericSet::values() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.GenericSet.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GenericSet::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.GenericSet.values)
  return &values_;
}

// -------------------------------------------------------------------

// RelatedEventSet

// -------------------------------------------------------------------

// RelatedNameMap

// -------------------------------------------------------------------

// Scalar

// -------------------------------------------------------------------

// Diagnostic

// .catapult.tracing.tracing.proto.Breakdown breakdown = 1;
inline bool Diagnostic::_internal_has_breakdown() const {
  return diagnostic_oneof_case() == kBreakdown;
}
inline bool Diagnostic::has_breakdown() const {
  return _internal_has_breakdown();
}
inline void Diagnostic::set_has_breakdown() {
  _oneof_case_[0] = kBreakdown;
}
inline void Diagnostic::clear_breakdown() {
  if (_internal_has_breakdown()) {
    if (GetArena() == nullptr) {
      delete diagnostic_oneof_.breakdown_;
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::Breakdown* Diagnostic::release_breakdown() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  if (_internal_has_breakdown()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::Breakdown* temp = diagnostic_oneof_.breakdown_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    diagnostic_oneof_.breakdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::Breakdown& Diagnostic::_internal_breakdown() const {
  return _internal_has_breakdown()
      ? *diagnostic_oneof_.breakdown_
      : reinterpret_cast< ::catapult::tracing::tracing::proto::Breakdown&>(::catapult::tracing::tracing::proto::_Breakdown_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::Breakdown& Diagnostic::breakdown() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  return _internal_breakdown();
}
inline ::catapult::tracing::tracing::proto::Breakdown* Diagnostic::unsafe_arena_release_breakdown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  if (_internal_has_breakdown()) {
    clear_has_diagnostic_oneof();
    ::catapult::tracing::tracing::proto::Breakdown* temp = diagnostic_oneof_.breakdown_;
    diagnostic_oneof_.breakdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_breakdown(::catapult::tracing::tracing::proto::Breakdown* breakdown) {
  clear_diagnostic_oneof();
  if (breakdown) {
    set_has_breakdown();
    diagnostic_oneof_.breakdown_ = breakdown;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.breakdown)
}
inline ::catapult::tracing::tracing::proto::Breakdown* Diagnostic::_internal_mutable_breakdown() {
  if (!_internal_has_breakdown()) {
    clear_diagnostic_oneof();
    set_has_breakdown();
    diagnostic_oneof_.breakdown_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::Breakdown >(GetArena());
  }
  return diagnostic_oneof_.breakdown_;
}
inline ::catapult::tracing::tracing::proto::Breakdown* Diagnostic::mutable_breakdown() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  return _internal_mutable_breakdown();
}

// .catapult.tracing.tracing.proto.DateRange date_range = 2;
inline bool Diagnostic::_internal_has_date_range() const {
  return diagnostic_oneof_case() == kDateRange;
}
inline bool Diagnostic::has_date_range() const {
  return _internal_has_date_range();
}
inline void Diagnostic::set_has_date_range() {
  _oneof_case_[0] = kDateRange;
}
inline void Diagnostic::clear_date_range() {
  if (_internal_has_date_range()) {
    if (GetArena() == nullptr) {
      delete diagnostic_oneof_.date_range_;
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::DateRange* Diagnostic::release_date_range() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.date_range)
  if (_internal_has_date_range()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::DateRange* temp = diagnostic_oneof_.date_range_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    diagnostic_oneof_.date_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::DateRange& Diagnostic::_internal_date_range() const {
  return _internal_has_date_range()
      ? *diagnostic_oneof_.date_range_
      : reinterpret_cast< ::catapult::tracing::tracing::proto::DateRange&>(::catapult::tracing::tracing::proto::_DateRange_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::DateRange& Diagnostic::date_range() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.date_range)
  return _internal_date_range();
}
inline ::catapult::tracing::tracing::proto::DateRange* Diagnostic::unsafe_arena_release_date_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.date_range)
  if (_internal_has_date_range()) {
    clear_has_diagnostic_oneof();
    ::catapult::tracing::tracing::proto::DateRange* temp = diagnostic_oneof_.date_range_;
    diagnostic_oneof_.date_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_date_range(::catapult::tracing::tracing::proto::DateRange* date_range) {
  clear_diagnostic_oneof();
  if (date_range) {
    set_has_date_range();
    diagnostic_oneof_.date_range_ = date_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.date_range)
}
inline ::catapult::tracing::tracing::proto::DateRange* Diagnostic::_internal_mutable_date_range() {
  if (!_internal_has_date_range()) {
    clear_diagnostic_oneof();
    set_has_date_range();
    diagnostic_oneof_.date_range_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::DateRange >(GetArena());
  }
  return diagnostic_oneof_.date_range_;
}
inline ::catapult::tracing::tracing::proto::DateRange* Diagnostic::mutable_date_range() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.date_range)
  return _internal_mutable_date_range();
}

// .catapult.tracing.tracing.proto.GenericSet generic_set = 3;
inline bool Diagnostic::_internal_has_generic_set() const {
  return diagnostic_oneof_case() == kGenericSet;
}
inline bool Diagnostic::has_generic_set() const {
  return _internal_has_generic_set();
}
inline void Diagnostic::set_has_generic_set() {
  _oneof_case_[0] = kGenericSet;
}
inline void Diagnostic::clear_generic_set() {
  if (_internal_has_generic_set()) {
    if (GetArena() == nullptr) {
      delete diagnostic_oneof_.generic_set_;
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::GenericSet* Diagnostic::release_generic_set() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  if (_internal_has_generic_set()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::GenericSet* temp = diagnostic_oneof_.generic_set_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    diagnostic_oneof_.generic_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::GenericSet& Diagnostic::_internal_generic_set() const {
  return _internal_has_generic_set()
      ? *diagnostic_oneof_.generic_set_
      : reinterpret_cast< ::catapult::tracing::tracing::proto::GenericSet&>(::catapult::tracing::tracing::proto::_GenericSet_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::GenericSet& Diagnostic::generic_set() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  return _internal_generic_set();
}
inline ::catapult::tracing::tracing::proto::GenericSet* Diagnostic::unsafe_arena_release_generic_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  if (_internal_has_generic_set()) {
    clear_has_diagnostic_oneof();
    ::catapult::tracing::tracing::proto::GenericSet* temp = diagnostic_oneof_.generic_set_;
    diagnostic_oneof_.generic_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_generic_set(::catapult::tracing::tracing::proto::GenericSet* generic_set) {
  clear_diagnostic_oneof();
  if (generic_set) {
    set_has_generic_set();
    diagnostic_oneof_.generic_set_ = generic_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.generic_set)
}
inline ::catapult::tracing::tracing::proto::GenericSet* Diagnostic::_internal_mutable_generic_set() {
  if (!_internal_has_generic_set()) {
    clear_diagnostic_oneof();
    set_has_generic_set();
    diagnostic_oneof_.generic_set_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::GenericSet >(GetArena());
  }
  return diagnostic_oneof_.generic_set_;
}
inline ::catapult::tracing::tracing::proto::GenericSet* Diagnostic::mutable_generic_set() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  return _internal_mutable_generic_set();
}

// .catapult.tracing.tracing.proto.RelatedEventSet related_event_set = 4;
inline bool Diagnostic::_internal_has_related_event_set() const {
  return diagnostic_oneof_case() == kRelatedEventSet;
}
inline bool Diagnostic::has_related_event_set() const {
  return _internal_has_related_event_set();
}
inline void Diagnostic::set_has_related_event_set() {
  _oneof_case_[0] = kRelatedEventSet;
}
inline void Diagnostic::clear_related_event_set() {
  if (_internal_has_related_event_set()) {
    if (GetArena() == nullptr) {
      delete diagnostic_oneof_.related_event_set_;
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* Diagnostic::release_related_event_set() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  if (_internal_has_related_event_set()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::RelatedEventSet* temp = diagnostic_oneof_.related_event_set_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    diagnostic_oneof_.related_event_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::RelatedEventSet& Diagnostic::_internal_related_event_set() const {
  return _internal_has_related_event_set()
      ? *diagnostic_oneof_.related_event_set_
      : reinterpret_cast< ::catapult::tracing::tracing::proto::RelatedEventSet&>(::catapult::tracing::tracing::proto::_RelatedEventSet_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::RelatedEventSet& Diagnostic::related_event_set() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  return _internal_related_event_set();
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* Diagnostic::unsafe_arena_release_related_event_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  if (_internal_has_related_event_set()) {
    clear_has_diagnostic_oneof();
    ::catapult::tracing::tracing::proto::RelatedEventSet* temp = diagnostic_oneof_.related_event_set_;
    diagnostic_oneof_.related_event_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_related_event_set(::catapult::tracing::tracing::proto::RelatedEventSet* related_event_set) {
  clear_diagnostic_oneof();
  if (related_event_set) {
    set_has_related_event_set();
    diagnostic_oneof_.related_event_set_ = related_event_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* Diagnostic::_internal_mutable_related_event_set() {
  if (!_internal_has_related_event_set()) {
    clear_diagnostic_oneof();
    set_has_related_event_set();
    diagnostic_oneof_.related_event_set_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::RelatedEventSet >(GetArena());
  }
  return diagnostic_oneof_.related_event_set_;
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* Diagnostic::mutable_related_event_set() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  return _internal_mutable_related_event_set();
}

// .catapult.tracing.tracing.proto.RelatedNameMap related_name_map = 5;
inline bool Diagnostic::_internal_has_related_name_map() const {
  return diagnostic_oneof_case() == kRelatedNameMap;
}
inline bool Diagnostic::has_related_name_map() const {
  return _internal_has_related_name_map();
}
inline void Diagnostic::set_has_related_name_map() {
  _oneof_case_[0] = kRelatedNameMap;
}
inline void Diagnostic::clear_related_name_map() {
  if (_internal_has_related_name_map()) {
    if (GetArena() == nullptr) {
      delete diagnostic_oneof_.related_name_map_;
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* Diagnostic::release_related_name_map() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  if (_internal_has_related_name_map()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::RelatedNameMap* temp = diagnostic_oneof_.related_name_map_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    diagnostic_oneof_.related_name_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::RelatedNameMap& Diagnostic::_internal_related_name_map() const {
  return _internal_has_related_name_map()
      ? *diagnostic_oneof_.related_name_map_
      : reinterpret_cast< ::catapult::tracing::tracing::proto::RelatedNameMap&>(::catapult::tracing::tracing::proto::_RelatedNameMap_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::RelatedNameMap& Diagnostic::related_name_map() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  return _internal_related_name_map();
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* Diagnostic::unsafe_arena_release_related_name_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  if (_internal_has_related_name_map()) {
    clear_has_diagnostic_oneof();
    ::catapult::tracing::tracing::proto::RelatedNameMap* temp = diagnostic_oneof_.related_name_map_;
    diagnostic_oneof_.related_name_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_related_name_map(::catapult::tracing::tracing::proto::RelatedNameMap* related_name_map) {
  clear_diagnostic_oneof();
  if (related_name_map) {
    set_has_related_name_map();
    diagnostic_oneof_.related_name_map_ = related_name_map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* Diagnostic::_internal_mutable_related_name_map() {
  if (!_internal_has_related_name_map()) {
    clear_diagnostic_oneof();
    set_has_related_name_map();
    diagnostic_oneof_.related_name_map_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::RelatedNameMap >(GetArena());
  }
  return diagnostic_oneof_.related_name_map_;
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* Diagnostic::mutable_related_name_map() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  return _internal_mutable_related_name_map();
}

// .catapult.tracing.tracing.proto.Scalar scalar = 6;
inline bool Diagnostic::_internal_has_scalar() const {
  return diagnostic_oneof_case() == kScalar;
}
inline bool Diagnostic::has_scalar() const {
  return _internal_has_scalar();
}
inline void Diagnostic::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void Diagnostic::clear_scalar() {
  if (_internal_has_scalar()) {
    if (GetArena() == nullptr) {
      delete diagnostic_oneof_.scalar_;
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::Scalar* Diagnostic::release_scalar() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.scalar)
  if (_internal_has_scalar()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::Scalar* temp = diagnostic_oneof_.scalar_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    diagnostic_oneof_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::Scalar& Diagnostic::_internal_scalar() const {
  return _internal_has_scalar()
      ? *diagnostic_oneof_.scalar_
      : reinterpret_cast< ::catapult::tracing::tracing::proto::Scalar&>(::catapult::tracing::tracing::proto::_Scalar_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::Scalar& Diagnostic::scalar() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.scalar)
  return _internal_scalar();
}
inline ::catapult::tracing::tracing::proto::Scalar* Diagnostic::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.scalar)
  if (_internal_has_scalar()) {
    clear_has_diagnostic_oneof();
    ::catapult::tracing::tracing::proto::Scalar* temp = diagnostic_oneof_.scalar_;
    diagnostic_oneof_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_scalar(::catapult::tracing::tracing::proto::Scalar* scalar) {
  clear_diagnostic_oneof();
  if (scalar) {
    set_has_scalar();
    diagnostic_oneof_.scalar_ = scalar;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.scalar)
}
inline ::catapult::tracing::tracing::proto::Scalar* Diagnostic::_internal_mutable_scalar() {
  if (!_internal_has_scalar()) {
    clear_diagnostic_oneof();
    set_has_scalar();
    diagnostic_oneof_.scalar_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::Scalar >(GetArena());
  }
  return diagnostic_oneof_.scalar_;
}
inline ::catapult::tracing::tracing::proto::Scalar* Diagnostic::mutable_scalar() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.scalar)
  return _internal_mutable_scalar();
}

// string shared_diagnostic_guid = 7;
inline bool Diagnostic::_internal_has_shared_diagnostic_guid() const {
  return diagnostic_oneof_case() == kSharedDiagnosticGuid;
}
inline void Diagnostic::set_has_shared_diagnostic_guid() {
  _oneof_case_[0] = kSharedDiagnosticGuid;
}
inline void Diagnostic::clear_shared_diagnostic_guid() {
  if (_internal_has_shared_diagnostic_guid()) {
    diagnostic_oneof_.shared_diagnostic_guid_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_diagnostic_oneof();
  }
}
inline const std::string& Diagnostic::shared_diagnostic_guid() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  return _internal_shared_diagnostic_guid();
}
inline void Diagnostic::set_shared_diagnostic_guid(const std::string& value) {
  _internal_set_shared_diagnostic_guid(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}
inline std::string* Diagnostic::mutable_shared_diagnostic_guid() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  return _internal_mutable_shared_diagnostic_guid();
}
inline const std::string& Diagnostic::_internal_shared_diagnostic_guid() const {
  if (_internal_has_shared_diagnostic_guid()) {
    return diagnostic_oneof_.shared_diagnostic_guid_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Diagnostic::_internal_set_shared_diagnostic_guid(const std::string& value) {
  if (!_internal_has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  diagnostic_oneof_.shared_diagnostic_guid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Diagnostic::set_shared_diagnostic_guid(std::string&& value) {
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  if (!_internal_has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  diagnostic_oneof_.shared_diagnostic_guid_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}
inline void Diagnostic::set_shared_diagnostic_guid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  diagnostic_oneof_.shared_diagnostic_guid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}
inline void Diagnostic::set_shared_diagnostic_guid(const char* value,
                             size_t size) {
  if (!_internal_has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  diagnostic_oneof_.shared_diagnostic_guid_.SetLite(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}
inline std::string* Diagnostic::_internal_mutable_shared_diagnostic_guid() {
  if (!_internal_has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return diagnostic_oneof_.shared_diagnostic_guid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Diagnostic::release_shared_diagnostic_guid() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  if (_internal_has_shared_diagnostic_guid()) {
    clear_has_diagnostic_oneof();
    return diagnostic_oneof_.shared_diagnostic_guid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Diagnostic::set_allocated_shared_diagnostic_guid(std::string* shared_diagnostic_guid) {
  if (has_diagnostic_oneof()) {
    clear_diagnostic_oneof();
  }
  if (shared_diagnostic_guid != nullptr) {
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(shared_diagnostic_guid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(shared_diagnostic_guid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}

inline bool Diagnostic::has_diagnostic_oneof() const {
  return diagnostic_oneof_case() != DIAGNOSTIC_ONEOF_NOT_SET;
}
inline void Diagnostic::clear_has_diagnostic_oneof() {
  _oneof_case_[0] = DIAGNOSTIC_ONEOF_NOT_SET;
}
inline Diagnostic::DiagnosticOneofCase Diagnostic::diagnostic_oneof_case() const {
  return Diagnostic::DiagnosticOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DiagnosticMap

// map<string, .catapult.tracing.tracing.proto.Diagnostic> diagnostic_map = 1;
inline int DiagnosticMap::_internal_diagnostic_map_size() const {
  return diagnostic_map_.size();
}
inline int DiagnosticMap::diagnostic_map_size() const {
  return _internal_diagnostic_map_size();
}
inline void DiagnosticMap::clear_diagnostic_map() {
  diagnostic_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
DiagnosticMap::_internal_diagnostic_map() const {
  return diagnostic_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
DiagnosticMap::diagnostic_map() const {
  // @@protoc_insertion_point(field_map:catapult.tracing.tracing.proto.DiagnosticMap.diagnostic_map)
  return _internal_diagnostic_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
DiagnosticMap::_internal_mutable_diagnostic_map() {
  return diagnostic_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
DiagnosticMap::mutable_diagnostic_map() {
  // @@protoc_insertion_point(field_mutable_map:catapult.tracing.tracing.proto.DiagnosticMap.diagnostic_map)
  return _internal_mutable_diagnostic_map();
}

// -------------------------------------------------------------------

// RunningStatistics

// int32 count = 1;
inline void RunningStatistics::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RunningStatistics::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RunningStatistics::count() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.count)
  return _internal_count();
}
inline void RunningStatistics::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void RunningStatistics::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.count)
}

// double max = 2;
inline void RunningStatistics::clear_max() {
  max_ = 0;
}
inline double RunningStatistics::_internal_max() const {
  return max_;
}
inline double RunningStatistics::max() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.max)
  return _internal_max();
}
inline void RunningStatistics::_internal_set_max(double value) {
  
  max_ = value;
}
inline void RunningStatistics::set_max(double value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.max)
}

// double meanlogs = 3;
inline void RunningStatistics::clear_meanlogs() {
  meanlogs_ = 0;
}
inline double RunningStatistics::_internal_meanlogs() const {
  return meanlogs_;
}
inline double RunningStatistics::meanlogs() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.meanlogs)
  return _internal_meanlogs();
}
inline void RunningStatistics::_internal_set_meanlogs(double value) {
  
  meanlogs_ = value;
}
inline void RunningStatistics::set_meanlogs(double value) {
  _internal_set_meanlogs(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.meanlogs)
}

// double mean = 4;
inline void RunningStatistics::clear_mean() {
  mean_ = 0;
}
inline double RunningStatistics::_internal_mean() const {
  return mean_;
}
inline double RunningStatistics::mean() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.mean)
  return _internal_mean();
}
inline void RunningStatistics::_internal_set_mean(double value) {
  
  mean_ = value;
}
inline void RunningStatistics::set_mean(double value) {
  _internal_set_mean(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.mean)
}

// double min = 5;
inline void RunningStatistics::clear_min() {
  min_ = 0;
}
inline double RunningStatistics::_internal_min() const {
  return min_;
}
inline double RunningStatistics::min() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.min)
  return _internal_min();
}
inline void RunningStatistics::_internal_set_min(double value) {
  
  min_ = value;
}
inline void RunningStatistics::set_min(double value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.min)
}

// double sum = 6;
inline void RunningStatistics::clear_sum() {
  sum_ = 0;
}
inline double RunningStatistics::_internal_sum() const {
  return sum_;
}
inline double RunningStatistics::sum() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.sum)
  return _internal_sum();
}
inline void RunningStatistics::_internal_set_sum(double value) {
  
  sum_ = value;
}
inline void RunningStatistics::set_sum(double value) {
  _internal_set_sum(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.sum)
}

// double variance = 7;
inline void RunningStatistics::clear_variance() {
  variance_ = 0;
}
inline double RunningStatistics::_internal_variance() const {
  return variance_;
}
inline double RunningStatistics::variance() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.variance)
  return _internal_variance();
}
inline void RunningStatistics::_internal_set_variance(double value) {
  
  variance_ = value;
}
inline void RunningStatistics::set_variance(double value) {
  _internal_set_variance(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.variance)
}

// -------------------------------------------------------------------

// Bin

// int32 bin_count = 1;
inline void Bin::clear_bin_count() {
  bin_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bin::_internal_bin_count() const {
  return bin_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bin::bin_count() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Bin.bin_count)
  return _internal_bin_count();
}
inline void Bin::_internal_set_bin_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  bin_count_ = value;
}
inline void Bin::set_bin_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bin_count(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Bin.bin_count)
}

// repeated .catapult.tracing.tracing.proto.DiagnosticMap diagnostic_maps = 2;
inline int Bin::_internal_diagnostic_maps_size() const {
  return diagnostic_maps_.size();
}
inline int Bin::diagnostic_maps_size() const {
  return _internal_diagnostic_maps_size();
}
inline void Bin::clear_diagnostic_maps() {
  diagnostic_maps_.Clear();
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Bin::mutable_diagnostic_maps(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return diagnostic_maps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >*
Bin::mutable_diagnostic_maps() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return &diagnostic_maps_;
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Bin::_internal_diagnostic_maps(int index) const {
  return diagnostic_maps_.Get(index);
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Bin::diagnostic_maps(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return _internal_diagnostic_maps(index);
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Bin::_internal_add_diagnostic_maps() {
  return diagnostic_maps_.Add();
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Bin::add_diagnostic_maps() {
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return _internal_add_diagnostic_maps();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >&
Bin::diagnostic_maps() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return diagnostic_maps_;
}

// -------------------------------------------------------------------

// SummaryOptions

// bool avg = 1;
inline void SummaryOptions::clear_avg() {
  avg_ = false;
}
inline bool SummaryOptions::_internal_avg() const {
  return avg_;
}
inline bool SummaryOptions::avg() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.avg)
  return _internal_avg();
}
inline void SummaryOptions::_internal_set_avg(bool value) {
  
  avg_ = value;
}
inline void SummaryOptions::set_avg(bool value) {
  _internal_set_avg(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.avg)
}

// bool geometric_mean = 2;
inline void SummaryOptions::clear_geometric_mean() {
  geometric_mean_ = false;
}
inline bool SummaryOptions::_internal_geometric_mean() const {
  return geometric_mean_;
}
inline bool SummaryOptions::geometric_mean() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.geometric_mean)
  return _internal_geometric_mean();
}
inline void SummaryOptions::_internal_set_geometric_mean(bool value) {
  
  geometric_mean_ = value;
}
inline void SummaryOptions::set_geometric_mean(bool value) {
  _internal_set_geometric_mean(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.geometric_mean)
}

// bool std = 3;
inline void SummaryOptions::clear_std() {
  std_ = false;
}
inline bool SummaryOptions::_internal_std() const {
  return std_;
}
inline bool SummaryOptions::std() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.std)
  return _internal_std();
}
inline void SummaryOptions::_internal_set_std(bool value) {
  
  std_ = value;
}
inline void SummaryOptions::set_std(bool value) {
  _internal_set_std(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.std)
}

// bool count = 4;
inline void SummaryOptions::clear_count() {
  count_ = false;
}
inline bool SummaryOptions::_internal_count() const {
  return count_;
}
inline bool SummaryOptions::count() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.count)
  return _internal_count();
}
inline void SummaryOptions::_internal_set_count(bool value) {
  
  count_ = value;
}
inline void SummaryOptions::set_count(bool value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.count)
}

// bool sum = 5;
inline void SummaryOptions::clear_sum() {
  sum_ = false;
}
inline bool SummaryOptions::_internal_sum() const {
  return sum_;
}
inline bool SummaryOptions::sum() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.sum)
  return _internal_sum();
}
inline void SummaryOptions::_internal_set_sum(bool value) {
  
  sum_ = value;
}
inline void SummaryOptions::set_sum(bool value) {
  _internal_set_sum(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.sum)
}

// bool min = 6;
inline void SummaryOptions::clear_min() {
  min_ = false;
}
inline bool SummaryOptions::_internal_min() const {
  return min_;
}
inline bool SummaryOptions::min() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.min)
  return _internal_min();
}
inline void SummaryOptions::_internal_set_min(bool value) {
  
  min_ = value;
}
inline void SummaryOptions::set_min(bool value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.min)
}

// bool max = 7;
inline void SummaryOptions::clear_max() {
  max_ = false;
}
inline bool SummaryOptions::_internal_max() const {
  return max_;
}
inline bool SummaryOptions::max() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.max)
  return _internal_max();
}
inline void SummaryOptions::_internal_set_max(bool value) {
  
  max_ = value;
}
inline void SummaryOptions::set_max(bool value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.max)
}

// bool nans = 8;
inline void SummaryOptions::clear_nans() {
  nans_ = false;
}
inline bool SummaryOptions::_internal_nans() const {
  return nans_;
}
inline bool SummaryOptions::nans() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.nans)
  return _internal_nans();
}
inline void SummaryOptions::_internal_set_nans(bool value) {
  
  nans_ = value;
}
inline void SummaryOptions::set_nans(bool value) {
  _internal_set_nans(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.nans)
}

// repeated float percentile = 9;
inline int SummaryOptions::_internal_percentile_size() const {
  return percentile_.size();
}
inline int SummaryOptions::percentile_size() const {
  return _internal_percentile_size();
}
inline void SummaryOptions::clear_percentile() {
  percentile_.Clear();
}
inline float SummaryOptions::_internal_percentile(int index) const {
  return percentile_.Get(index);
}
inline float SummaryOptions::percentile(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.percentile)
  return _internal_percentile(index);
}
inline void SummaryOptions::set_percentile(int index, float value) {
  percentile_.Set(index, value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.percentile)
}
inline void SummaryOptions::_internal_add_percentile(float value) {
  percentile_.Add(value);
}
inline void SummaryOptions::add_percentile(float value) {
  _internal_add_percentile(value);
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.SummaryOptions.percentile)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SummaryOptions::_internal_percentile() const {
  return percentile_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SummaryOptions::percentile() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.SummaryOptions.percentile)
  return _internal_percentile();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SummaryOptions::_internal_mutable_percentile() {
  return &percentile_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SummaryOptions::mutable_percentile() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.SummaryOptions.percentile)
  return _internal_mutable_percentile();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Histogram

// string name = 1;
inline void Histogram::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Histogram::name() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.name)
  return _internal_name();
}
inline void Histogram::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.name)
}
inline std::string* Histogram::mutable_name() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.name)
  return _internal_mutable_name();
}
inline const std::string& Histogram::_internal_name() const {
  return name_.Get();
}
inline void Histogram::_internal_set_name(const std::string& value) {
  
  name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Histogram::set_name(std::string&& value) {
  
  name_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:catapult.tracing.tracing.proto.Histogram.name)
}
inline void Histogram::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:catapult.tracing.tracing.proto.Histogram.name)
}
inline void Histogram::set_name(const char* value,
    size_t size) {
  
  name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:catapult.tracing.tracing.proto.Histogram.name)
}
inline std::string* Histogram::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Histogram::release_name() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Histogram::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.name)
}

// .catapult.tracing.tracing.proto.UnitAndDirection unit = 2;
inline bool Histogram::_internal_has_unit() const {
  return this != internal_default_instance() && unit_ != nullptr;
}
inline bool Histogram::has_unit() const {
  return _internal_has_unit();
}
inline void Histogram::clear_unit() {
  if (GetArena() == nullptr && unit_ != nullptr) {
    delete unit_;
  }
  unit_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::UnitAndDirection& Histogram::_internal_unit() const {
  const ::catapult::tracing::tracing::proto::UnitAndDirection* p = unit_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::UnitAndDirection&>(
      ::catapult::tracing::tracing::proto::_UnitAndDirection_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::UnitAndDirection& Histogram::unit() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.unit)
  return _internal_unit();
}
inline void Histogram::unsafe_arena_set_allocated_unit(
    ::catapult::tracing::tracing::proto::UnitAndDirection* unit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_);
  }
  unit_ = unit;
  if (unit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.unit)
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* Histogram::release_unit() {
  
  ::catapult::tracing::tracing::proto::UnitAndDirection* temp = unit_;
  unit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* Histogram::unsafe_arena_release_unit() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.unit)
  
  ::catapult::tracing::tracing::proto::UnitAndDirection* temp = unit_;
  unit_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* Histogram::_internal_mutable_unit() {
  
  if (unit_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::UnitAndDirection>(GetArena());
    unit_ = p;
  }
  return unit_;
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* Histogram::mutable_unit() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.unit)
  return _internal_mutable_unit();
}
inline void Histogram::set_allocated_unit(::catapult::tracing::tracing::proto::UnitAndDirection* unit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete unit_;
  }
  if (unit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(unit);
    if (message_arena != submessage_arena) {
      unit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.unit)
}

// .catapult.tracing.tracing.proto.BinBoundaries bin_boundaries = 3;
inline bool Histogram::_internal_has_bin_boundaries() const {
  return this != internal_default_instance() && bin_boundaries_ != nullptr;
}
inline bool Histogram::has_bin_boundaries() const {
  return _internal_has_bin_boundaries();
}
inline void Histogram::clear_bin_boundaries() {
  if (GetArena() == nullptr && bin_boundaries_ != nullptr) {
    delete bin_boundaries_;
  }
  bin_boundaries_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::BinBoundaries& Histogram::_internal_bin_boundaries() const {
  const ::catapult::tracing::tracing::proto::BinBoundaries* p = bin_boundaries_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::BinBoundaries&>(
      ::catapult::tracing::tracing::proto::_BinBoundaries_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::BinBoundaries& Histogram::bin_boundaries() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
  return _internal_bin_boundaries();
}
inline void Histogram::unsafe_arena_set_allocated_bin_boundaries(
    ::catapult::tracing::tracing::proto::BinBoundaries* bin_boundaries) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bin_boundaries_);
  }
  bin_boundaries_ = bin_boundaries;
  if (bin_boundaries) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* Histogram::release_bin_boundaries() {
  
  ::catapult::tracing::tracing::proto::BinBoundaries* temp = bin_boundaries_;
  bin_boundaries_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* Histogram::unsafe_arena_release_bin_boundaries() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
  
  ::catapult::tracing::tracing::proto::BinBoundaries* temp = bin_boundaries_;
  bin_boundaries_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* Histogram::_internal_mutable_bin_boundaries() {
  
  if (bin_boundaries_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::BinBoundaries>(GetArena());
    bin_boundaries_ = p;
  }
  return bin_boundaries_;
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* Histogram::mutable_bin_boundaries() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
  return _internal_mutable_bin_boundaries();
}
inline void Histogram::set_allocated_bin_boundaries(::catapult::tracing::tracing::proto::BinBoundaries* bin_boundaries) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bin_boundaries_;
  }
  if (bin_boundaries) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bin_boundaries);
    if (message_arena != submessage_arena) {
      bin_boundaries = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bin_boundaries, submessage_arena);
    }
    
  } else {
    
  }
  bin_boundaries_ = bin_boundaries;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
}

// string description = 4;
inline void Histogram::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Histogram::description() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.description)
  return _internal_description();
}
inline void Histogram::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.description)
}
inline std::string* Histogram::mutable_description() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.description)
  return _internal_mutable_description();
}
inline const std::string& Histogram::_internal_description() const {
  return description_.Get();
}
inline void Histogram::_internal_set_description(const std::string& value) {
  
  description_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Histogram::set_description(std::string&& value) {
  
  description_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:catapult.tracing.tracing.proto.Histogram.description)
}
inline void Histogram::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:catapult.tracing.tracing.proto.Histogram.description)
}
inline void Histogram::set_description(const char* value,
    size_t size) {
  
  description_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:catapult.tracing.tracing.proto.Histogram.description)
}
inline std::string* Histogram::_internal_mutable_description() {
  
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Histogram::release_description() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Histogram::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.description)
}

// .catapult.tracing.tracing.proto.DiagnosticMap diagnostics = 5;
inline bool Histogram::_internal_has_diagnostics() const {
  return this != internal_default_instance() && diagnostics_ != nullptr;
}
inline bool Histogram::has_diagnostics() const {
  return _internal_has_diagnostics();
}
inline void Histogram::clear_diagnostics() {
  if (GetArena() == nullptr && diagnostics_ != nullptr) {
    delete diagnostics_;
  }
  diagnostics_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Histogram::_internal_diagnostics() const {
  const ::catapult::tracing::tracing::proto::DiagnosticMap* p = diagnostics_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::DiagnosticMap&>(
      ::catapult::tracing::tracing::proto::_DiagnosticMap_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Histogram::diagnostics() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.diagnostics)
  return _internal_diagnostics();
}
inline void Histogram::unsafe_arena_set_allocated_diagnostics(
    ::catapult::tracing::tracing::proto::DiagnosticMap* diagnostics) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diagnostics_);
  }
  diagnostics_ = diagnostics;
  if (diagnostics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.diagnostics)
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::release_diagnostics() {
  
  ::catapult::tracing::tracing::proto::DiagnosticMap* temp = diagnostics_;
  diagnostics_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::unsafe_arena_release_diagnostics() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.diagnostics)
  
  ::catapult::tracing::tracing::proto::DiagnosticMap* temp = diagnostics_;
  diagnostics_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::_internal_mutable_diagnostics() {
  
  if (diagnostics_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::DiagnosticMap>(GetArena());
    diagnostics_ = p;
  }
  return diagnostics_;
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::mutable_diagnostics() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.diagnostics)
  return _internal_mutable_diagnostics();
}
inline void Histogram::set_allocated_diagnostics(::catapult::tracing::tracing::proto::DiagnosticMap* diagnostics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete diagnostics_;
  }
  if (diagnostics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(diagnostics);
    if (message_arena != submessage_arena) {
      diagnostics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diagnostics, submessage_arena);
    }
    
  } else {
    
  }
  diagnostics_ = diagnostics;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.diagnostics)
}

// repeated double sample_values = 6;
inline int Histogram::_internal_sample_values_size() const {
  return sample_values_.size();
}
inline int Histogram::sample_values_size() const {
  return _internal_sample_values_size();
}
inline void Histogram::clear_sample_values() {
  sample_values_.Clear();
}
inline double Histogram::_internal_sample_values(int index) const {
  return sample_values_.Get(index);
}
inline double Histogram::sample_values(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.sample_values)
  return _internal_sample_values(index);
}
inline void Histogram::set_sample_values(int index, double value) {
  sample_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.sample_values)
}
inline void Histogram::_internal_add_sample_values(double value) {
  sample_values_.Add(value);
}
inline void Histogram::add_sample_values(double value) {
  _internal_add_sample_values(value);
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.Histogram.sample_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Histogram::_internal_sample_values() const {
  return sample_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Histogram::sample_values() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.Histogram.sample_values)
  return _internal_sample_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Histogram::_internal_mutable_sample_values() {
  return &sample_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Histogram::mutable_sample_values() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.Histogram.sample_values)
  return _internal_mutable_sample_values();
}

// int32 max_num_sample_values = 7;
inline void Histogram::clear_max_num_sample_values() {
  max_num_sample_values_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Histogram::_internal_max_num_sample_values() const {
  return max_num_sample_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Histogram::max_num_sample_values() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.max_num_sample_values)
  return _internal_max_num_sample_values();
}
inline void Histogram::_internal_set_max_num_sample_values(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_num_sample_values_ = value;
}
inline void Histogram::set_max_num_sample_values(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_num_sample_values(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.max_num_sample_values)
}

// int32 num_nans = 8;
inline void Histogram::clear_num_nans() {
  num_nans_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Histogram::_internal_num_nans() const {
  return num_nans_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Histogram::num_nans() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.num_nans)
  return _internal_num_nans();
}
inline void Histogram::_internal_set_num_nans(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_nans_ = value;
}
inline void Histogram::set_num_nans(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_nans(value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.num_nans)
}

// repeated .catapult.tracing.tracing.proto.DiagnosticMap nan_diagnostics = 9;
inline int Histogram::_internal_nan_diagnostics_size() const {
  return nan_diagnostics_.size();
}
inline int Histogram::nan_diagnostics_size() const {
  return _internal_nan_diagnostics_size();
}
inline void Histogram::clear_nan_diagnostics() {
  nan_diagnostics_.Clear();
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::mutable_nan_diagnostics(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return nan_diagnostics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >*
Histogram::mutable_nan_diagnostics() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return &nan_diagnostics_;
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Histogram::_internal_nan_diagnostics(int index) const {
  return nan_diagnostics_.Get(index);
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Histogram::nan_diagnostics(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return _internal_nan_diagnostics(index);
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::_internal_add_nan_diagnostics() {
  return nan_diagnostics_.Add();
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::add_nan_diagnostics() {
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return _internal_add_nan_diagnostics();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >&
Histogram::nan_diagnostics() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return nan_diagnostics_;
}

// .catapult.tracing.tracing.proto.RunningStatistics running = 10;
inline bool Histogram::_internal_has_running() const {
  return this != internal_default_instance() && running_ != nullptr;
}
inline bool Histogram::has_running() const {
  return _internal_has_running();
}
inline void Histogram::clear_running() {
  if (GetArena() == nullptr && running_ != nullptr) {
    delete running_;
  }
  running_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::RunningStatistics& Histogram::_internal_running() const {
  const ::catapult::tracing::tracing::proto::RunningStatistics* p = running_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::RunningStatistics&>(
      ::catapult::tracing::tracing::proto::_RunningStatistics_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::RunningStatistics& Histogram::running() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.running)
  return _internal_running();
}
inline void Histogram::unsafe_arena_set_allocated_running(
    ::catapult::tracing::tracing::proto::RunningStatistics* running) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(running_);
  }
  running_ = running;
  if (running) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.running)
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* Histogram::release_running() {
  
  ::catapult::tracing::tracing::proto::RunningStatistics* temp = running_;
  running_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* Histogram::unsafe_arena_release_running() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.running)
  
  ::catapult::tracing::tracing::proto::RunningStatistics* temp = running_;
  running_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* Histogram::_internal_mutable_running() {
  
  if (running_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::RunningStatistics>(GetArena());
    running_ = p;
  }
  return running_;
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* Histogram::mutable_running() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.running)
  return _internal_mutable_running();
}
inline void Histogram::set_allocated_running(::catapult::tracing::tracing::proto::RunningStatistics* running) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete running_;
  }
  if (running) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(running);
    if (message_arena != submessage_arena) {
      running = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, running, submessage_arena);
    }
    
  } else {
    
  }
  running_ = running;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.running)
}

// map<int32, .catapult.tracing.tracing.proto.Bin> all_bins = 11;
inline int Histogram::_internal_all_bins_size() const {
  return all_bins_.size();
}
inline int Histogram::all_bins_size() const {
  return _internal_all_bins_size();
}
inline void Histogram::clear_all_bins() {
  all_bins_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >&
Histogram::_internal_all_bins() const {
  return all_bins_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >&
Histogram::all_bins() const {
  // @@protoc_insertion_point(field_map:catapult.tracing.tracing.proto.Histogram.all_bins)
  return _internal_all_bins();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >*
Histogram::_internal_mutable_all_bins() {
  return all_bins_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >*
Histogram::mutable_all_bins() {
  // @@protoc_insertion_point(field_mutable_map:catapult.tracing.tracing.proto.Histogram.all_bins)
  return _internal_mutable_all_bins();
}

// .catapult.tracing.tracing.proto.SummaryOptions summary_options = 12;
inline bool Histogram::_internal_has_summary_options() const {
  return this != internal_default_instance() && summary_options_ != nullptr;
}
inline bool Histogram::has_summary_options() const {
  return _internal_has_summary_options();
}
inline void Histogram::clear_summary_options() {
  if (GetArena() == nullptr && summary_options_ != nullptr) {
    delete summary_options_;
  }
  summary_options_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::SummaryOptions& Histogram::_internal_summary_options() const {
  const ::catapult::tracing::tracing::proto::SummaryOptions* p = summary_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::SummaryOptions&>(
      ::catapult::tracing::tracing::proto::_SummaryOptions_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::SummaryOptions& Histogram::summary_options() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.summary_options)
  return _internal_summary_options();
}
inline void Histogram::unsafe_arena_set_allocated_summary_options(
    ::catapult::tracing::tracing::proto::SummaryOptions* summary_options) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(summary_options_);
  }
  summary_options_ = summary_options;
  if (summary_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.summary_options)
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* Histogram::release_summary_options() {
  
  ::catapult::tracing::tracing::proto::SummaryOptions* temp = summary_options_;
  summary_options_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* Histogram::unsafe_arena_release_summary_options() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.summary_options)
  
  ::catapult::tracing::tracing::proto::SummaryOptions* temp = summary_options_;
  summary_options_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* Histogram::_internal_mutable_summary_options() {
  
  if (summary_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::SummaryOptions>(GetArena());
    summary_options_ = p;
  }
  return summary_options_;
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* Histogram::mutable_summary_options() {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.summary_options)
  return _internal_mutable_summary_options();
}
inline void Histogram::set_allocated_summary_options(::catapult::tracing::tracing::proto::SummaryOptions* summary_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete summary_options_;
  }
  if (summary_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(summary_options);
    if (message_arena != submessage_arena) {
      summary_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, summary_options, submessage_arena);
    }
    
  } else {
    
  }
  summary_options_ = summary_options;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.summary_options)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HistogramSet

// repeated .catapult.tracing.tracing.proto.Histogram histograms = 1;
inline int HistogramSet::_internal_histograms_size() const {
  return histograms_.size();
}
inline int HistogramSet::histograms_size() const {
  return _internal_histograms_size();
}
inline void HistogramSet::clear_histograms() {
  histograms_.Clear();
}
inline ::catapult::tracing::tracing::proto::Histogram* HistogramSet::mutable_histograms(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return histograms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram >*
HistogramSet::mutable_histograms() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return &histograms_;
}
inline const ::catapult::tracing::tracing::proto::Histogram& HistogramSet::_internal_histograms(int index) const {
  return histograms_.Get(index);
}
inline const ::catapult::tracing::tracing::proto::Histogram& HistogramSet::histograms(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return _internal_histograms(index);
}
inline ::catapult::tracing::tracing::proto::Histogram* HistogramSet::_internal_add_histograms() {
  return histograms_.Add();
}
inline ::catapult::tracing::tracing::proto::Histogram* HistogramSet::add_histograms() {
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return _internal_add_histograms();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram >&
HistogramSet::histograms() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return histograms_;
}

// map<string, .catapult.tracing.tracing.proto.Diagnostic> shared_diagnostics = 2;
inline int HistogramSet::_internal_shared_diagnostics_size() const {
  return shared_diagnostics_.size();
}
inline int HistogramSet::shared_diagnostics_size() const {
  return _internal_shared_diagnostics_size();
}
inline void HistogramSet::clear_shared_diagnostics() {
  shared_diagnostics_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
HistogramSet::_internal_shared_diagnostics() const {
  return shared_diagnostics_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
HistogramSet::shared_diagnostics() const {
  // @@protoc_insertion_point(field_map:catapult.tracing.tracing.proto.HistogramSet.shared_diagnostics)
  return _internal_shared_diagnostics();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
HistogramSet::_internal_mutable_shared_diagnostics() {
  return shared_diagnostics_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
HistogramSet::mutable_shared_diagnostics() {
  // @@protoc_insertion_point(field_mutable_map:catapult.tracing.tracing.proto.HistogramSet.shared_diagnostics)
  return _internal_mutable_shared_diagnostics();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tracing
}  // namespace tracing
}  // namespace catapult

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::catapult::tracing::tracing::proto::ImprovementDirection> : ::std::true_type {};
template <> struct is_proto_enum< ::catapult::tracing::tracing::proto::Unit> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_histogram_2eproto
